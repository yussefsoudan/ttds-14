{"ast":null,"code":"var Utils = require(\"./util\"),\n    Headers = require(\"./headers\"),\n    Constants = Utils.Constants,\n    Methods = require(\"./methods\");\n\nmodule.exports = function (\n/*Buffer*/\ninput) {\n  var _entryHeader = new Headers.EntryHeader(),\n      _entryName = Buffer.alloc(0),\n      _comment = Buffer.alloc(0),\n      _isDirectory = false,\n      uncompressedData = null,\n      _extra = Buffer.alloc(0);\n\n  function getCompressedDataFromZip() {\n    if (!input || !Buffer.isBuffer(input)) {\n      return Buffer.alloc(0);\n    }\n\n    _entryHeader.loadDataHeaderFromBinary(input);\n\n    return input.slice(_entryHeader.realDataOffset, _entryHeader.realDataOffset + _entryHeader.compressedSize);\n  }\n\n  function crc32OK(data) {\n    // if bit 3 (0x08) of the general-purpose flags field is set, then the CRC-32 and file sizes are not known when the header is written\n    if ((_entryHeader.flags & 0x8) !== 0x8) {\n      if (Utils.crc32(data) !== _entryHeader.dataHeader.crc) {\n        return false;\n      }\n    } else {// @TODO: load and check data descriptor header\n      // The fields in the local header are filled with zero, and the CRC-32 and size are appended in a 12-byte structure\n      // (optionally preceded by a 4-byte signature) immediately after the compressed data:\n    }\n\n    return true;\n  }\n\n  function decompress(\n  /*Boolean*/\n  async,\n  /*Function*/\n  callback,\n  /*String*/\n  pass) {\n    if (typeof callback === 'undefined' && typeof async === 'string') {\n      pass = async;\n      async = void 0;\n    }\n\n    if (_isDirectory) {\n      if (async && callback) {\n        callback(Buffer.alloc(0), Utils.Errors.DIRECTORY_CONTENT_ERROR); //si added error.\n      }\n\n      return Buffer.alloc(0);\n    }\n\n    var compressedData = getCompressedDataFromZip();\n\n    if (compressedData.length === 0) {\n      // File is empty, nothing to decompress.\n      if (async && callback) callback(compressedData);\n      return compressedData;\n    }\n\n    var data = Buffer.alloc(_entryHeader.size);\n\n    switch (_entryHeader.method) {\n      case Utils.Constants.STORED:\n        compressedData.copy(data);\n\n        if (!crc32OK(data)) {\n          if (async && callback) callback(data, Utils.Errors.BAD_CRC); //si added error\n\n          throw new Error(Utils.Errors.BAD_CRC);\n        } else {\n          //si added otherwise did not seem to return data.\n          if (async && callback) callback(data);\n          return data;\n        }\n\n      case Utils.Constants.DEFLATED:\n        var inflater = new Methods.Inflater(compressedData);\n\n        if (!async) {\n          var result = inflater.inflate(data);\n          result.copy(data, 0);\n\n          if (!crc32OK(data)) {\n            throw new Error(Utils.Errors.BAD_CRC + \" \" + _entryName.toString());\n          }\n\n          return data;\n        } else {\n          inflater.inflateAsync(function (result) {\n            result.copy(data, 0);\n\n            if (!crc32OK(data)) {\n              if (callback) callback(data, Utils.Errors.BAD_CRC); //si added error\n            } else {\n              //si added otherwise did not seem to return data.\n              if (callback) callback(data);\n            }\n          });\n        }\n\n        break;\n\n      default:\n        if (async && callback) callback(Buffer.alloc(0), Utils.Errors.UNKNOWN_METHOD);\n        throw new Error(Utils.Errors.UNKNOWN_METHOD);\n    }\n  }\n\n  function compress(\n  /*Boolean*/\n  async,\n  /*Function*/\n  callback) {\n    if ((!uncompressedData || !uncompressedData.length) && Buffer.isBuffer(input)) {\n      // no data set or the data wasn't changed to require recompression\n      if (async && callback) callback(getCompressedDataFromZip());\n      return getCompressedDataFromZip();\n    }\n\n    if (uncompressedData.length && !_isDirectory) {\n      var compressedData; // Local file header\n\n      switch (_entryHeader.method) {\n        case Utils.Constants.STORED:\n          _entryHeader.compressedSize = _entryHeader.size;\n          compressedData = Buffer.alloc(uncompressedData.length);\n          uncompressedData.copy(compressedData);\n          if (async && callback) callback(compressedData);\n          return compressedData;\n\n        default:\n        case Utils.Constants.DEFLATED:\n          var deflater = new Methods.Deflater(uncompressedData);\n\n          if (!async) {\n            var deflated = deflater.deflate();\n            _entryHeader.compressedSize = deflated.length;\n            return deflated;\n          } else {\n            deflater.deflateAsync(function (data) {\n              compressedData = Buffer.alloc(data.length);\n              _entryHeader.compressedSize = data.length;\n              data.copy(compressedData);\n              callback && callback(compressedData);\n            });\n          }\n\n          deflater = null;\n          break;\n      }\n    } else {\n      if (async && callback) {\n        callback(Buffer.alloc(0));\n      } else {\n        return Buffer.alloc(0);\n      }\n    }\n  }\n\n  function readUInt64LE(buffer, offset) {\n    return (buffer.readUInt32LE(offset + 4) << 4) + buffer.readUInt32LE(offset);\n  }\n\n  function parseExtra(data) {\n    var offset = 0;\n    var signature, size, part;\n\n    while (offset < data.length) {\n      signature = data.readUInt16LE(offset);\n      offset += 2;\n      size = data.readUInt16LE(offset);\n      offset += 2;\n      part = data.slice(offset, offset + size);\n      offset += size;\n\n      if (Constants.ID_ZIP64 === signature) {\n        parseZip64ExtendedInformation(part);\n      }\n    }\n  } //Override header field values with values from the ZIP64 extra field\n\n\n  function parseZip64ExtendedInformation(data) {\n    var size, compressedSize, offset, diskNumStart;\n\n    if (data.length >= Constants.EF_ZIP64_SCOMP) {\n      size = readUInt64LE(data, Constants.EF_ZIP64_SUNCOMP);\n\n      if (_entryHeader.size === Constants.EF_ZIP64_OR_32) {\n        _entryHeader.size = size;\n      }\n    }\n\n    if (data.length >= Constants.EF_ZIP64_RHO) {\n      compressedSize = readUInt64LE(data, Constants.EF_ZIP64_SCOMP);\n\n      if (_entryHeader.compressedSize === Constants.EF_ZIP64_OR_32) {\n        _entryHeader.compressedSize = compressedSize;\n      }\n    }\n\n    if (data.length >= Constants.EF_ZIP64_DSN) {\n      offset = readUInt64LE(data, Constants.EF_ZIP64_RHO);\n\n      if (_entryHeader.offset === Constants.EF_ZIP64_OR_32) {\n        _entryHeader.offset = offset;\n      }\n    }\n\n    if (data.length >= Constants.EF_ZIP64_DSN + 4) {\n      diskNumStart = data.readUInt32LE(Constants.EF_ZIP64_DSN);\n\n      if (_entryHeader.diskNumStart === Constants.EF_ZIP64_OR_16) {\n        _entryHeader.diskNumStart = diskNumStart;\n      }\n    }\n  }\n\n  return {\n    get entryName() {\n      return _entryName.toString();\n    },\n\n    get rawEntryName() {\n      return _entryName;\n    },\n\n    set entryName(val) {\n      _entryName = Utils.toBuffer(val);\n      var lastChar = _entryName[_entryName.length - 1];\n      _isDirectory = lastChar === 47 || lastChar === 92;\n      _entryHeader.fileNameLength = _entryName.length;\n    },\n\n    get extra() {\n      return _extra;\n    },\n\n    set extra(val) {\n      _extra = val;\n      _entryHeader.extraLength = val.length;\n      parseExtra(val);\n    },\n\n    get comment() {\n      return _comment.toString();\n    },\n\n    set comment(val) {\n      _comment = Utils.toBuffer(val);\n      _entryHeader.commentLength = _comment.length;\n    },\n\n    get name() {\n      var n = _entryName.toString();\n\n      return _isDirectory ? n.substr(n.length - 1).split(\"/\").pop() : n.split(\"/\").pop();\n    },\n\n    get isDirectory() {\n      return _isDirectory;\n    },\n\n    getCompressedData: function () {\n      return compress(false, null);\n    },\n    getCompressedDataAsync: function (\n    /*Function*/\n    callback) {\n      compress(true, callback);\n    },\n    setData: function (value) {\n      uncompressedData = Utils.toBuffer(value);\n\n      if (!_isDirectory && uncompressedData.length) {\n        _entryHeader.size = uncompressedData.length;\n        _entryHeader.method = Utils.Constants.DEFLATED;\n        _entryHeader.crc = Utils.crc32(value);\n        _entryHeader.changed = true;\n      } else {\n        // folders and blank files should be stored\n        _entryHeader.method = Utils.Constants.STORED;\n      }\n    },\n    getData: function (pass) {\n      if (_entryHeader.changed) {\n        return uncompressedData;\n      } else {\n        return decompress(false, null, pass);\n      }\n    },\n    getDataAsync: function (\n    /*Function*/\n    callback, pass) {\n      if (_entryHeader.changed) {\n        callback(uncompressedData);\n      } else {\n        decompress(true, callback, pass);\n      }\n    },\n\n    set attr(attr) {\n      _entryHeader.attr = attr;\n    },\n\n    get attr() {\n      return _entryHeader.attr;\n    },\n\n    set header(\n    /*Buffer*/\n    data) {\n      _entryHeader.loadFromBinary(data);\n    },\n\n    get header() {\n      return _entryHeader;\n    },\n\n    packHeader: function () {\n      var header = _entryHeader.entryHeaderToBinary(); // add\n\n\n      _entryName.copy(header, Utils.Constants.CENHDR);\n\n      if (_entryHeader.extraLength) {\n        _extra.copy(header, Utils.Constants.CENHDR + _entryName.length);\n      }\n\n      if (_entryHeader.commentLength) {\n        _comment.copy(header, Utils.Constants.CENHDR + _entryName.length + _entryHeader.extraLength, _comment.length);\n      }\n\n      return header;\n    },\n    toString: function () {\n      return '{\\n' + '\\t\"entryName\" : \"' + _entryName.toString() + \"\\\",\\n\" + '\\t\"name\" : \"' + (_isDirectory ? _entryName.toString().replace(/\\/$/, '').split(\"/\").pop() : _entryName.toString().split(\"/\").pop()) + \"\\\",\\n\" + '\\t\"comment\" : \"' + _comment.toString() + \"\\\",\\n\" + '\\t\"isDirectory\" : ' + _isDirectory + \",\\n\" + '\\t\"header\" : ' + _entryHeader.toString().replace(/\\t/mg, \"\\t\\t\").replace(/}/mg, \"\\t}\") + \",\\n\" + '\\t\"compressedData\" : <' + (input && input.length + \" bytes buffer\" || \"null\") + \">\\n\" + '\\t\"data\" : <' + (uncompressedData && uncompressedData.length + \" bytes buffer\" || \"null\") + \">\\n\" + '}';\n    }\n  };\n};","map":{"version":3,"sources":["/Users/yussefsoudan/Studies/Uni/year-4-cs/TTDS/CW3/ttds-14/website/book-search-client/node_modules/adm-zip/zipEntry.js"],"names":["Utils","require","Headers","Constants","Methods","module","exports","input","_entryHeader","EntryHeader","_entryName","Buffer","alloc","_comment","_isDirectory","uncompressedData","_extra","getCompressedDataFromZip","isBuffer","loadDataHeaderFromBinary","slice","realDataOffset","compressedSize","crc32OK","data","flags","crc32","dataHeader","crc","decompress","async","callback","pass","Errors","DIRECTORY_CONTENT_ERROR","compressedData","length","size","method","STORED","copy","BAD_CRC","Error","DEFLATED","inflater","Inflater","result","inflate","toString","inflateAsync","UNKNOWN_METHOD","compress","deflater","Deflater","deflated","deflate","deflateAsync","readUInt64LE","buffer","offset","readUInt32LE","parseExtra","signature","part","readUInt16LE","ID_ZIP64","parseZip64ExtendedInformation","diskNumStart","EF_ZIP64_SCOMP","EF_ZIP64_SUNCOMP","EF_ZIP64_OR_32","EF_ZIP64_RHO","EF_ZIP64_DSN","EF_ZIP64_OR_16","entryName","rawEntryName","val","toBuffer","lastChar","fileNameLength","extra","extraLength","comment","commentLength","name","n","substr","split","pop","isDirectory","getCompressedData","getCompressedDataAsync","setData","value","changed","getData","getDataAsync","attr","header","loadFromBinary","packHeader","entryHeaderToBinary","CENHDR","replace"],"mappings":"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","sourcesContent":["var Utils = require(\"./util\"),\r\n    Headers = require(\"./headers\"),\r\n    Constants = Utils.Constants,\r\n    Methods = require(\"./methods\");\r\n\r\nmodule.exports = function (/*Buffer*/input) {\r\n\r\n    var _entryHeader = new Headers.EntryHeader(),\r\n        _entryName = Buffer.alloc(0),\r\n        _comment = Buffer.alloc(0),\r\n        _isDirectory = false,\r\n        uncompressedData = null,\r\n        _extra = Buffer.alloc(0);\r\n\r\n    function getCompressedDataFromZip() {\r\n        if (!input || !Buffer.isBuffer(input)) {\r\n            return Buffer.alloc(0);\r\n        }\r\n        _entryHeader.loadDataHeaderFromBinary(input);\r\n        return input.slice(_entryHeader.realDataOffset, _entryHeader.realDataOffset + _entryHeader.compressedSize)\r\n    }\r\n\r\n    function crc32OK(data) {\r\n        // if bit 3 (0x08) of the general-purpose flags field is set, then the CRC-32 and file sizes are not known when the header is written\r\n        if ((_entryHeader.flags & 0x8) !== 0x8) {\r\n           if (Utils.crc32(data) !== _entryHeader.dataHeader.crc) {\r\n               return false;\r\n           }\r\n        } else {\r\n            // @TODO: load and check data descriptor header\r\n            // The fields in the local header are filled with zero, and the CRC-32 and size are appended in a 12-byte structure\r\n            // (optionally preceded by a 4-byte signature) immediately after the compressed data:\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function decompress(/*Boolean*/async, /*Function*/callback, /*String*/pass) {\r\n        if(typeof callback === 'undefined' && typeof async === 'string') {\r\n            pass=async;\r\n            async=void 0;\r\n        }\r\n        if (_isDirectory) {\r\n            if (async && callback) {\r\n                callback(Buffer.alloc(0), Utils.Errors.DIRECTORY_CONTENT_ERROR); //si added error.\r\n            }\r\n            return Buffer.alloc(0);\r\n        }\r\n\r\n        var compressedData = getCompressedDataFromZip();\r\n\r\n        if (compressedData.length === 0) {\r\n            // File is empty, nothing to decompress.\r\n            if (async && callback) callback(compressedData);\r\n            return compressedData;\r\n        }\r\n\r\n        var data = Buffer.alloc(_entryHeader.size);\r\n\r\n        switch (_entryHeader.method) {\r\n            case Utils.Constants.STORED:\r\n                compressedData.copy(data);\r\n                if (!crc32OK(data)) {\r\n                    if (async && callback) callback(data, Utils.Errors.BAD_CRC);//si added error\r\n                    throw new Error(Utils.Errors.BAD_CRC);\r\n                } else {//si added otherwise did not seem to return data.\r\n                    if (async && callback) callback(data);\r\n                    return data;\r\n                }\r\n            case Utils.Constants.DEFLATED:\r\n                var inflater = new Methods.Inflater(compressedData);\r\n                if (!async) {\r\n                    var result = inflater.inflate(data);\r\n                    result.copy(data, 0);\r\n                    if (!crc32OK(data)) {\r\n                        throw new Error(Utils.Errors.BAD_CRC + \" \" + _entryName.toString());\r\n                    }\r\n                    return data;\r\n                } else {\r\n                    inflater.inflateAsync(function(result) {\r\n                        result.copy(data, 0);\r\n                        if (!crc32OK(data)) {\r\n                            if (callback) callback(data, Utils.Errors.BAD_CRC); //si added error\r\n                        } else { //si added otherwise did not seem to return data.\r\n                            if (callback) callback(data);\r\n                        }\r\n                    })\r\n                }\r\n                break;\r\n            default:\r\n                if (async && callback) callback(Buffer.alloc(0), Utils.Errors.UNKNOWN_METHOD);\r\n                throw new Error(Utils.Errors.UNKNOWN_METHOD);\r\n        }\r\n    }\r\n\r\n    function compress(/*Boolean*/async, /*Function*/callback) {\r\n        if ((!uncompressedData || !uncompressedData.length) && Buffer.isBuffer(input)) {\r\n            // no data set or the data wasn't changed to require recompression\r\n            if (async && callback) callback(getCompressedDataFromZip());\r\n            return getCompressedDataFromZip();\r\n        }\r\n\r\n        if (uncompressedData.length && !_isDirectory) {\r\n            var compressedData;\r\n            // Local file header\r\n            switch (_entryHeader.method) {\r\n                case Utils.Constants.STORED:\r\n                    _entryHeader.compressedSize = _entryHeader.size;\r\n\r\n                    compressedData = Buffer.alloc(uncompressedData.length);\r\n                    uncompressedData.copy(compressedData);\r\n\r\n                    if (async && callback) callback(compressedData);\r\n                    return compressedData;\r\n                default:\r\n                case Utils.Constants.DEFLATED:\r\n\r\n                    var deflater = new Methods.Deflater(uncompressedData);\r\n                    if (!async) {\r\n                        var deflated = deflater.deflate();\r\n                        _entryHeader.compressedSize = deflated.length;\r\n                        return deflated;\r\n                    } else {\r\n                        deflater.deflateAsync(function(data) {\r\n                            compressedData = Buffer.alloc(data.length);\r\n                            _entryHeader.compressedSize = data.length;\r\n                            data.copy(compressedData);\r\n                            callback && callback(compressedData);\r\n                        })\r\n                    }\r\n                    deflater = null;\r\n                    break;\r\n            }\r\n        } else {\r\n            if (async && callback) {\r\n                callback(Buffer.alloc(0));\r\n            } else {\r\n                return Buffer.alloc(0);\r\n            }\r\n        }\r\n    }\r\n\r\n    function readUInt64LE(buffer, offset) {\r\n        return (buffer.readUInt32LE(offset + 4) << 4) + buffer.readUInt32LE(offset);\r\n    }\r\n\r\n    function parseExtra(data) {\r\n        var offset = 0;\r\n        var signature, size, part;\r\n        while(offset<data.length) {\r\n            signature = data.readUInt16LE(offset);\r\n            offset += 2;\r\n            size = data.readUInt16LE(offset);\r\n            offset += 2;\r\n            part = data.slice(offset, offset+size);\r\n            offset += size;\r\n            if(Constants.ID_ZIP64 === signature) {\r\n                parseZip64ExtendedInformation(part);\r\n            }\r\n        }\r\n    }\r\n\r\n    //Override header field values with values from the ZIP64 extra field\r\n    function parseZip64ExtendedInformation(data) {\r\n        var size, compressedSize, offset, diskNumStart;\r\n\r\n        if(data.length >= Constants.EF_ZIP64_SCOMP) {\r\n            size = readUInt64LE(data, Constants.EF_ZIP64_SUNCOMP);\r\n            if(_entryHeader.size === Constants.EF_ZIP64_OR_32) {\r\n                _entryHeader.size = size;\r\n            }\r\n        }\r\n        if(data.length >= Constants.EF_ZIP64_RHO) {\r\n            compressedSize = readUInt64LE(data, Constants.EF_ZIP64_SCOMP);\r\n            if(_entryHeader.compressedSize === Constants.EF_ZIP64_OR_32) {\r\n                _entryHeader.compressedSize = compressedSize;\r\n            }\r\n        }\r\n        if(data.length >= Constants.EF_ZIP64_DSN) {\r\n            offset = readUInt64LE(data, Constants.EF_ZIP64_RHO);\r\n            if(_entryHeader.offset === Constants.EF_ZIP64_OR_32) {\r\n                _entryHeader.offset = offset;\r\n            }\r\n        }\r\n        if(data.length >= Constants.EF_ZIP64_DSN+4) {\r\n            diskNumStart = data.readUInt32LE(Constants.EF_ZIP64_DSN);\r\n            if(_entryHeader.diskNumStart === Constants.EF_ZIP64_OR_16) {\r\n                _entryHeader.diskNumStart = diskNumStart;\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    return {\r\n        get entryName () { return _entryName.toString(); },\r\n        get rawEntryName() { return _entryName; },\r\n        set entryName (val) {\r\n            _entryName = Utils.toBuffer(val);\r\n            var lastChar = _entryName[_entryName.length - 1];\r\n            _isDirectory = (lastChar === 47) || (lastChar === 92);\r\n            _entryHeader.fileNameLength = _entryName.length;\r\n        },\r\n\r\n        get extra () { return _extra; },\r\n        set extra (val) {\r\n            _extra = val;\r\n            _entryHeader.extraLength = val.length;\r\n            parseExtra(val);\r\n        },\r\n\r\n        get comment () { return _comment.toString(); },\r\n        set comment (val) {\r\n            _comment = Utils.toBuffer(val);\r\n            _entryHeader.commentLength = _comment.length;\r\n        },\r\n\r\n        get name () { var n = _entryName.toString(); return _isDirectory ? n.substr(n.length - 1).split(\"/\").pop() : n.split(\"/\").pop(); },\r\n        get isDirectory () { return _isDirectory },\r\n\r\n        getCompressedData : function() {\r\n            return compress(false, null)\r\n        },\r\n\r\n        getCompressedDataAsync : function(/*Function*/callback) {\r\n            compress(true, callback)\r\n        },\r\n\r\n        setData : function(value) {\r\n            uncompressedData = Utils.toBuffer(value);\r\n            if (!_isDirectory && uncompressedData.length) {\r\n                _entryHeader.size = uncompressedData.length;\r\n                _entryHeader.method = Utils.Constants.DEFLATED;\r\n                _entryHeader.crc = Utils.crc32(value);\r\n                _entryHeader.changed = true;\r\n            } else { // folders and blank files should be stored\r\n                _entryHeader.method = Utils.Constants.STORED;\r\n            }\r\n        },\r\n\r\n        getData : function(pass) {\r\n            if (_entryHeader.changed) {\r\n\t\t\t\treturn uncompressedData;\r\n\t\t\t} else {\r\n\t\t\t\treturn decompress(false, null, pass);\r\n            }\r\n        },\r\n\r\n        getDataAsync : function(/*Function*/callback, pass) {\r\n\t\t\tif (_entryHeader.changed) {\r\n\t\t\t\tcallback(uncompressedData)\r\n\t\t\t} else {\r\n\t\t\t\tdecompress(true, callback, pass)\r\n            }\r\n        },\r\n\r\n        set attr(attr) { _entryHeader.attr = attr; },\r\n        get attr() { return _entryHeader.attr; },\r\n\r\n        set header(/*Buffer*/data) {\r\n            _entryHeader.loadFromBinary(data);\r\n        },\r\n\r\n        get header() {\r\n            return _entryHeader;\r\n        },\r\n\r\n        packHeader : function() {\r\n            var header = _entryHeader.entryHeaderToBinary();\r\n            // add\r\n            _entryName.copy(header, Utils.Constants.CENHDR);\r\n            if (_entryHeader.extraLength) {\r\n                _extra.copy(header, Utils.Constants.CENHDR + _entryName.length)\r\n            }\r\n            if (_entryHeader.commentLength) {\r\n                _comment.copy(header, Utils.Constants.CENHDR + _entryName.length + _entryHeader.extraLength, _comment.length);\r\n            }\r\n            return header;\r\n        },\r\n\r\n        toString : function() {\r\n            return '{\\n' +\r\n                '\\t\"entryName\" : \"' + _entryName.toString() + \"\\\",\\n\" +\r\n                '\\t\"name\" : \"' + (_isDirectory ? _entryName.toString().replace(/\\/$/, '').split(\"/\").pop() : _entryName.toString().split(\"/\").pop()) + \"\\\",\\n\" +\r\n                '\\t\"comment\" : \"' + _comment.toString() + \"\\\",\\n\" +\r\n                '\\t\"isDirectory\" : ' + _isDirectory + \",\\n\" +\r\n                '\\t\"header\" : ' + _entryHeader.toString().replace(/\\t/mg, \"\\t\\t\").replace(/}/mg, \"\\t}\")  + \",\\n\" +\r\n                '\\t\"compressedData\" : <' + (input && input.length  + \" bytes buffer\" || \"null\") + \">\\n\" +\r\n                '\\t\"data\" : <' + (uncompressedData && uncompressedData.length  + \" bytes buffer\" || \"null\") + \">\\n\" +\r\n                '}';\r\n        }\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}