{"ast":null,"code":"// TheSpanishInquisition\n// Cache the matrix. Note that if you not pass a limit this implementation will use a dynamically calculate one.\nmodule.exports = function (__this, that, limit) {\n  var thisLength = __this.length,\n      thatLength = that.length,\n      matrix = []; // If the limit is not defined it will be calculate from this and that args.\n\n  limit = (limit || (thatLength > thisLength ? thatLength : thisLength)) + 1;\n\n  for (var i = 0; i < limit; i++) {\n    matrix[i] = [i];\n    matrix[i].length = limit;\n  }\n\n  for (i = 0; i < limit; i++) {\n    matrix[0][i] = i;\n  }\n\n  if (Math.abs(thisLength - thatLength) > (limit || 100)) {\n    return prepare(limit || 100);\n  }\n\n  if (thisLength === 0) {\n    return prepare(thatLength);\n  }\n\n  if (thatLength === 0) {\n    return prepare(thisLength);\n  } // Calculate matrix.\n\n\n  var j, this_i, that_j, cost, min, t;\n\n  for (i = 1; i <= thisLength; ++i) {\n    this_i = __this[i - 1]; // Step 4\n\n    for (j = 1; j <= thatLength; ++j) {\n      // Check the jagged ld total so far\n      if (i === j && matrix[i][j] > 4) return prepare(thisLength);\n      that_j = that[j - 1];\n      cost = this_i === that_j ? 0 : 1; // Step 5\n      // Calculate the minimum (much faster than Math.min(...)).\n\n      min = matrix[i - 1][j] + 1; // Deletion.\n\n      if ((t = matrix[i][j - 1] + 1) < min) min = t; // Insertion.\n\n      if ((t = matrix[i - 1][j - 1] + cost) < min) min = t; // Substitution.\n      // Update matrix.\n\n      matrix[i][j] = i > 1 && j > 1 && this_i === that[j - 2] && __this[i - 2] === that_j && (t = matrix[i - 2][j - 2] + cost) < min ? t : min; // Transposition.\n    }\n  }\n\n  return prepare(matrix[thisLength][thatLength]);\n  /**\n   *\n   */\n\n  function prepare(steps) {\n    var length = Math.max(thisLength, thatLength);\n    var relative = length === 0 ? 0 : steps / length;\n    var similarity = 1 - relative;\n    return {\n      steps: steps,\n      relative: relative,\n      similarity: similarity\n    };\n  }\n};","map":{"version":3,"sources":["/Users/yussefsoudan/Studies/Uni/year-4-cs/TTDS/CW3/ttds-14/website/book-search-client/node_modules/damerau-levenshtein/index.js"],"names":["module","exports","__this","that","limit","thisLength","length","thatLength","matrix","i","Math","abs","prepare","j","this_i","that_j","cost","min","t","steps","max","relative","similarity"],"mappings":"AAAA;AAEA;AAEAA,MAAM,CAACC,OAAP,GAAiB,UAASC,MAAT,EAAiBC,IAAjB,EAAuBC,KAAvB,EAA8B;AAE7C,MAAIC,UAAU,GAAGH,MAAM,CAACI,MAAxB;AAAA,MACIC,UAAU,GAAGJ,IAAI,CAACG,MADtB;AAAA,MAEIE,MAAM,GAAG,EAFb,CAF6C,CAM7C;;AACAJ,EAAAA,KAAK,GAAG,CAACA,KAAK,KAAMG,UAAU,GAAGF,UAAb,GAA0BE,UAA1B,GAAuCF,UAA7C,CAAN,IAAiE,CAAzE;;AAEA,OAAK,IAAII,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGL,KAApB,EAA2BK,CAAC,EAA5B,EAAgC;AAC9BD,IAAAA,MAAM,CAACC,CAAD,CAAN,GAAY,CAACA,CAAD,CAAZ;AACAD,IAAAA,MAAM,CAACC,CAAD,CAAN,CAAUH,MAAV,GAAmBF,KAAnB;AACD;;AACD,OAAKK,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGL,KAAhB,EAAuBK,CAAC,EAAxB,EAA4B;AAC1BD,IAAAA,MAAM,CAAC,CAAD,CAAN,CAAUC,CAAV,IAAeA,CAAf;AACD;;AAED,MAAIC,IAAI,CAACC,GAAL,CAASN,UAAU,GAAGE,UAAtB,KAAqCH,KAAK,IAAI,GAA9C,CAAJ,EAAuD;AACrD,WAAOQ,OAAO,CAAER,KAAK,IAAI,GAAX,CAAd;AACD;;AACD,MAAIC,UAAU,KAAK,CAAnB,EAAqB;AACnB,WAAOO,OAAO,CAAEL,UAAF,CAAd;AACD;;AACD,MAAIA,UAAU,KAAK,CAAnB,EAAqB;AACnB,WAAOK,OAAO,CAAEP,UAAF,CAAd;AACD,GAzB4C,CA2B7C;;;AACA,MAAIQ,CAAJ,EAAOC,MAAP,EAAeC,MAAf,EAAuBC,IAAvB,EAA6BC,GAA7B,EAAkCC,CAAlC;;AACA,OAAKT,CAAC,GAAG,CAAT,EAAYA,CAAC,IAAIJ,UAAjB,EAA6B,EAAEI,CAA/B,EAAkC;AAChCK,IAAAA,MAAM,GAAGZ,MAAM,CAACO,CAAC,GAAC,CAAH,CAAf,CADgC,CAGhC;;AACA,SAAKI,CAAC,GAAG,CAAT,EAAYA,CAAC,IAAIN,UAAjB,EAA6B,EAAEM,CAA/B,EAAkC;AAChC;AACA,UAAIJ,CAAC,KAAKI,CAAN,IAAWL,MAAM,CAACC,CAAD,CAAN,CAAUI,CAAV,IAAe,CAA9B,EAAiC,OAAOD,OAAO,CAAEP,UAAF,CAAd;AAEjCU,MAAAA,MAAM,GAAGZ,IAAI,CAACU,CAAC,GAAC,CAAH,CAAb;AACAG,MAAAA,IAAI,GAAIF,MAAM,KAAKC,MAAZ,GAAsB,CAAtB,GAA0B,CAAjC,CALgC,CAKI;AACpC;;AACAE,MAAAA,GAAG,GAAMT,MAAM,CAACC,CAAC,GAAG,CAAL,CAAN,CAAcI,CAAd,IAAuB,CAAhC,CAPgC,CAOG;;AACnC,UAAI,CAACK,CAAC,GAAGV,MAAM,CAACC,CAAD,CAAN,CAAcI,CAAC,GAAG,CAAlB,IAAuB,CAA5B,IAAoCI,GAAxC,EAA6CA,GAAG,GAAGC,CAAN,CARb,CAQwB;;AACxD,UAAI,CAACA,CAAC,GAAGV,MAAM,CAACC,CAAC,GAAG,CAAL,CAAN,CAAcI,CAAC,GAAG,CAAlB,IAAuBG,IAA5B,IAAoCC,GAAxC,EAA6CA,GAAG,GAAGC,CAAN,CATb,CASwB;AAExD;;AACAV,MAAAA,MAAM,CAACC,CAAD,CAAN,CAAUI,CAAV,IAAgBJ,CAAC,GAAG,CAAJ,IAASI,CAAC,GAAG,CAAb,IAAkBC,MAAM,KAAKX,IAAI,CAACU,CAAC,GAAC,CAAH,CAAjC,IAA0CX,MAAM,CAACO,CAAC,GAAC,CAAH,CAAN,KAAgBM,MAA1D,IAAoE,CAACG,CAAC,GAAGV,MAAM,CAACC,CAAC,GAAC,CAAH,CAAN,CAAYI,CAAC,GAAC,CAAd,IAAiBG,IAAtB,IAA8BC,GAAnG,GAA0GC,CAA1G,GAA8GD,GAA7H,CAZgC,CAYkG;AACnI;AACF;;AAED,SAAOL,OAAO,CAAEJ,MAAM,CAACH,UAAD,CAAN,CAAmBE,UAAnB,CAAF,CAAd;AAEF;AACA;AACA;;AACE,WAASK,OAAT,CAAiBO,KAAjB,EAAwB;AACtB,QAAIb,MAAM,GAAGI,IAAI,CAACU,GAAL,CAASf,UAAT,EAAqBE,UAArB,CAAb;AACA,QAAIc,QAAQ,GAAGf,MAAM,KAAK,CAAX,GACX,CADW,GAEVa,KAAK,GAAGb,MAFb;AAGA,QAAIgB,UAAU,GAAG,IAAID,QAArB;AACA,WAAO;AACLF,MAAAA,KAAK,EAAEA,KADF;AAELE,MAAAA,QAAQ,EAAEA,QAFL;AAGLC,MAAAA,UAAU,EAAEA;AAHP,KAAP;AAKD;AAEF,CAnED","sourcesContent":["// TheSpanishInquisition\n\n// Cache the matrix. Note that if you not pass a limit this implementation will use a dynamically calculate one.\n\nmodule.exports = function(__this, that, limit) {\n\n  var thisLength = __this.length,\n      thatLength = that.length,\n      matrix = [];\n\n  // If the limit is not defined it will be calculate from this and that args.\n  limit = (limit || ((thatLength > thisLength ? thatLength : thisLength)))+1;\n\n  for (var i = 0; i < limit; i++) {\n    matrix[i] = [i];\n    matrix[i].length = limit;\n  }\n  for (i = 0; i < limit; i++) {\n    matrix[0][i] = i;\n  }\n\n  if (Math.abs(thisLength - thatLength) > (limit || 100)){\n    return prepare (limit || 100);\n  }\n  if (thisLength === 0){\n    return prepare (thatLength);\n  }\n  if (thatLength === 0){\n    return prepare (thisLength);\n  }\n\n  // Calculate matrix.\n  var j, this_i, that_j, cost, min, t;\n  for (i = 1; i <= thisLength; ++i) {\n    this_i = __this[i-1];\n\n    // Step 4\n    for (j = 1; j <= thatLength; ++j) {\n      // Check the jagged ld total so far\n      if (i === j && matrix[i][j] > 4) return prepare (thisLength);\n\n      that_j = that[j-1];\n      cost = (this_i === that_j) ? 0 : 1; // Step 5\n      // Calculate the minimum (much faster than Math.min(...)).\n      min    = matrix[i - 1][j    ] + 1; // Deletion.\n      if ((t = matrix[i    ][j - 1] + 1   ) < min) min = t;   // Insertion.\n      if ((t = matrix[i - 1][j - 1] + cost) < min) min = t;   // Substitution.\n\n      // Update matrix.\n      matrix[i][j] = (i > 1 && j > 1 && this_i === that[j-2] && __this[i-2] === that_j && (t = matrix[i-2][j-2]+cost) < min) ? t : min; // Transposition.\n    }\n  }\n\n  return prepare (matrix[thisLength][thatLength]);\n\n/**\n *\n */\n  function prepare(steps) {\n    var length = Math.max(thisLength, thatLength)\n    var relative = length === 0\n      ? 0\n      : (steps / length);\n    var similarity = 1 - relative\n    return {\n      steps: steps,\n      relative: relative,\n      similarity: similarity\n    };\n  }\n\n};\n"]},"metadata":{},"sourceType":"script"}