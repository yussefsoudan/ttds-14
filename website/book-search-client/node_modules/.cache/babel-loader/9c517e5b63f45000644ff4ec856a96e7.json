{"ast":null,"code":"/*\r\n * Copyright (c) 2016 José F. Maldonado\r\n * This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0. \r\n * If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.\r\n */\n// Load dependencies.\nconst fs = require('fs');\n\nconst path = require('path');\n\nconst tmp = require('tmp');\n\nconst Zip = require('adm-zip');\n\nconst stripBOM = require('strip-bom');\n\nconst Dictionary = require('./dictionary.js');\n\nconst FOLDER_PATH = __dirname + '/dict'; // Define module.\n\nvar SpellChecker = {\n  /**\r\n   * Create a dictionary from a file, which might be either a .dic or a .zip file.\r\n   *\r\n   * @param {String} fileName The name of the file from which read the word list.\r\n   * @param {String} folderPath The path to the directory in which the file is located (optional).\r\n   * @param {Callback} callback A function to invoke when either the dictionary was created or an error was found.\r\n   */\n  getDictionary: function (fileName, folderPath\n  /*, callback*/\n  ) {\n    try {\n      // Initialize variables.\n      var folder = !folderPath || typeof folderPath != 'string' ? FOLDER_PATH : folderPath;\n      var callback = arguments[arguments.length - 1];\n      var dic_path = folder + '/' + fileName + '.dic';\n      var zip_path = folder + '/' + fileName + '.zip'; // Verify if the dictionary file exists.\n\n      fs.exists(dic_path, function (exists) {\n        if (exists) {\n          // The file exists, read it.\n          SpellChecker._readFile(dic_path, callback);\n        } else {\n          // The file do not exists, verify if the ZIP file exists.\n          fs.exists(zip_path, function (exists) {\n            if (exists) {\n              try {\n                // The file ZIP exists, unzip it.\n                SpellChecker._unzipSync(zip_path, folder);\n\n                SpellChecker._readFile(dic_path, callback);\n              } catch (errZip) {\n                // Return error.\n                if (callback) callback('An unexpected error ocurred: ' + errZip, null);\n              }\n            } else {\n              // The ZIP file also doesn't exists, return an error.\n              callback('The dictionary could not be read, no file with the name \"' + fileName + '\" could be found', null);\n            }\n          });\n        }\n      });\n    } catch (err) {\n      // Return error.\n      if (callback) callback('An unexpected error ocurred: ' + err, null);\n    }\n  },\n\n  /**\r\n   * Create a dictionary from a .dic file.\r\n   *\r\n   * @param {String} file_path The path of the file.\r\n   * @param {Callback} callback A function to invoke when either the dictionary was created or an error was found.\r\n   */\n  _readFile: function (file_path, callback) {\n    fs.readFile(file_path, 'utf8', function (err, text) {\n      // Check for errors.\n      if (!err) {\n        // Create dictionary and return it.\n        var dictionary = new Dictionary(text.split('\\n'));\n        callback(null, dictionary);\n      } else {\n        // Return an error.\n        callback(\"The dictionary file could not be read: \" + err, null);\n      }\n    });\n  },\n\n  /**\r\n   * Create a dictionary from a .dic file synchronously.\r\n   *\r\n   * @param {String} file_path The path of the file.\r\n   * @returns The created dictionary\r\n   * @throws An error if the file couldn't be opened\r\n   */\n  _readFileSync: function (file_path) {\n    try {\n      var text = fs.readFileSync(file_path, 'utf8'); // Create dictionary and return it.\n\n      var dictionary = new Dictionary(text.split('\\n'));\n      return dictionary;\n    } catch (err) {\n      // Return an error.\n      throw new Error(\"The dictionary file could not be read: \" + file_path + \". Error: \" + err);\n    }\n  },\n\n  /**\r\n   * Unzip a zip file.\r\n   *\r\n   * Each entry in the zip file will be extracted atomically. From the perspective of another\r\n   * process, the unzipped file will either not exist or will be fully unzipped.\r\n   *\r\n   * @param {String} zipPath The path of the zip file.\r\n   * @param {String} destinationDir The directory to unzip into.\r\n   * @throws An error if the file couldn't be unzipped.\r\n   */\n  _unzipSync: function (zipPath, destinationDir) {\n    // Unzip into a tmp directory.\n    var tmpDir = tmp.dirSync({\n      dir: destinationDir\n    });\n    var zip = new Zip(zipPath);\n    zip.extractAllTo(tmpDir.name); // Move the unzipped files out of the tmp directory and into the destination directory.\n\n    zip.getEntries().forEach(({\n      entryName\n    }) => {\n      var from = path.join(tmpDir.name, entryName);\n      var to = path.join(destinationDir, entryName);\n      fs.renameSync(from, to);\n    }); // Clean up the tmp directory\n\n    tmpDir.removeCallback();\n  },\n\n  /**\r\n   * Create a dictionary from a .dic file .\r\n   *\r\n   * @param {String} fileName The name of the file from which read the word list.\r\n   * @param {String} folderPath The path to the directory in which the file is located (optional).\r\n   * @return {Object} An instance of the Dictionary class.\r\n   * @throws {Exception} If the dictionary's file can't be found or is invalid.\r\n   */\n  getDictionarySync: function (fileName, folderPath) {\n    try {\n      // Initialize variables.\n      var folder = !folderPath || typeof folderPath != 'string' ? FOLDER_PATH : folderPath;\n      var dic_path = folder + '/' + fileName + '.dic';\n      var zip_path = folder + '/' + fileName + '.zip'; // Verify if the dictionary file exists.\n\n      if (fs.existsSync(dic_path)) {\n        // The file exists, read it.\n        var dictionary = SpellChecker._readFileSync(dic_path);\n\n        return dictionary;\n      } else {\n        // The file do not exists, verify if the ZIP file exists.\n        var exists = fs.existsSync(zip_path);\n\n        if (exists) {\n          // The file ZIP exists, unzip it.\n          SpellChecker._unzipSync(zip_path, folder);\n\n          var dictionary = SpellChecker._readFileSync(dic_path);\n\n          return dictionary;\n        } else {\n          // The ZIP file also doesn't exists, return an error.\n          throw new Error('The dictionary could not be read, no file with the name \"' + fileName + '\" could be found');\n        }\n      }\n    } catch (err) {\n      // Throw an error.\n      throw new Error('An unexpected error ocurred: ' + err);\n    }\n  },\n\n  /**\r\n   * Reads a UTF8 dictionary file, removes the BOM and \\r characters and sorts the list of words.\r\n   *\r\n   * @param {String} inputPath The path for the input file.\r\n   * @param {String} outputPath The path to output (optional, by default is equals to the input file).\r\n   * @param {Callback} callback A function to invoke after finishing.\r\n   */\n  normalizeDictionary: function (inputPath, outputPath\n  /*, callback*/\n  ) {\n    try {\n      // Parses arguments\n      if (!outputPath || typeof outputPath != 'string') outputPath = inputPath;\n      var callback = arguments.length > 0 ? arguments[arguments.length - 1] : function () {}; // Verify if the dictionary file exists.\n\n      fs.exists(inputPath, function (exists) {\n        if (exists) {\n          // The file exists, read it.\n          fs.readFile(inputPath, 'utf8', function (err, content) {\n            // Check for errors.\n            if (!err) {\n              // Remove BOM and \\r characters.\n              content = stripBOM(content);\n              content = content.replace(/\\r/g, ''); // Sort words.\n\n              var lines = content.split('\\n');\n              var collator = new Intl.Collator(); // Use this comparator for consider accents and special characters.\n\n              lines = lines.sort(collator.compare); // Generate output content.\n\n              var newContent = '';\n              var first = true;\n\n              for (var i = 0; i < lines.length; i++) {\n                if (lines[i] != '' && lines[i] != '\\n') {\n                  if (!first) newContent += '\\n';\n                  newContent += lines[i];\n                  first = false;\n                }\n              } // Write output file.\n\n\n              fs.writeFile(outputPath, newContent, 'utf8', function (err) {\n                // Return result.\n                callback(err ? \"The output file could not be writted: \" + err : null, !err);\n              });\n            } else {\n              // Return an error.\n              callback(\"The input file could not be read: \" + err, false);\n            }\n          });\n        } else {\n          // Return an error indicating that the file doens't exists.\n          callback(\"The input file does not exists\", false);\n        }\n      });\n    } catch (err) {\n      // Return an error.\n      callback('An unexpected error ocurred: ' + err, false);\n    }\n  }\n}; // Export module.\n\nmodule.exports = SpellChecker;","map":{"version":3,"sources":["/Users/yussefsoudan/Studies/Uni/year-4-cs/TTDS/CW3/ttds-14/website/book-search-client/node_modules/simple-spellchecker/index.js"],"names":["fs","require","path","tmp","Zip","stripBOM","Dictionary","FOLDER_PATH","__dirname","SpellChecker","getDictionary","fileName","folderPath","folder","callback","arguments","length","dic_path","zip_path","exists","_readFile","_unzipSync","errZip","err","file_path","readFile","text","dictionary","split","_readFileSync","readFileSync","Error","zipPath","destinationDir","tmpDir","dirSync","dir","zip","extractAllTo","name","getEntries","forEach","entryName","from","join","to","renameSync","removeCallback","getDictionarySync","existsSync","normalizeDictionary","inputPath","outputPath","content","replace","lines","collator","Intl","Collator","sort","compare","newContent","first","i","writeFile","module","exports"],"mappings":"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","sourcesContent":["/*\r\n * Copyright (c) 2016 José F. Maldonado\r\n * This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0. \r\n * If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.\r\n */\r\n\r\n// Load dependencies.\r\nconst fs = require('fs');\r\nconst path = require('path');\r\nconst tmp = require('tmp');\r\nconst Zip = require('adm-zip');\r\nconst stripBOM = require('strip-bom');\r\nconst Dictionary = require('./dictionary.js');\r\n\r\nconst FOLDER_PATH = __dirname + '/dict';\r\n\r\n// Define module.\r\nvar SpellChecker = {\r\n    /**\r\n     * Create a dictionary from a file, which might be either a .dic or a .zip file.\r\n     *\r\n     * @param {String} fileName The name of the file from which read the word list.\r\n     * @param {String} folderPath The path to the directory in which the file is located (optional).\r\n     * @param {Callback} callback A function to invoke when either the dictionary was created or an error was found.\r\n     */\r\n    getDictionary: function(fileName, folderPath /*, callback*/) {\r\n        try{\r\n            // Initialize variables.\r\n            var folder = (!folderPath || typeof folderPath != 'string')? FOLDER_PATH : folderPath;\r\n            var callback = arguments[arguments.length - 1];\r\n            var dic_path = folder + '/' + fileName + '.dic';\r\n            var zip_path = folder + '/' + fileName + '.zip';\r\n            \r\n            // Verify if the dictionary file exists.\r\n            fs.exists(dic_path, function(exists) {\r\n                if(exists) {\r\n                    // The file exists, read it.\r\n                    SpellChecker._readFile(dic_path, callback);\r\n                } else {\r\n                    // The file do not exists, verify if the ZIP file exists.\r\n                    fs.exists(zip_path, function(exists) {\r\n                        if(exists) {\r\n                            try{\r\n                                // The file ZIP exists, unzip it.\r\n                                SpellChecker._unzipSync(zip_path, folder);\r\n                                SpellChecker._readFile(dic_path, callback);\r\n                            } catch(errZip) {\r\n                                // Return error.\r\n                                if(callback) callback('An unexpected error ocurred: ' + errZip, null);\r\n                            }\r\n                        } else {\r\n                            // The ZIP file also doesn't exists, return an error.\r\n                            callback('The dictionary could not be read, no file with the name \"' + fileName + '\" could be found', null);\r\n                        } \r\n                    });\r\n                }\r\n            });\r\n        } catch(err) {\r\n            // Return error.\r\n            if(callback) callback('An unexpected error ocurred: ' + err, null);\r\n        }\r\n    },\r\n  \r\n    /**\r\n     * Create a dictionary from a .dic file.\r\n     *\r\n     * @param {String} file_path The path of the file.\r\n     * @param {Callback} callback A function to invoke when either the dictionary was created or an error was found.\r\n     */  \r\n    _readFile: function(file_path, callback) {\r\n        fs.readFile(file_path, 'utf8', function(err, text) {\r\n            // Check for errors.\r\n            if (!err) {\r\n                // Create dictionary and return it.\r\n                var dictionary = new Dictionary(text.split('\\n'));\r\n                callback(null, dictionary);\r\n            } else {\r\n                // Return an error.\r\n                callback(\"The dictionary file could not be read: \" + err, null);\r\n            }\r\n        });\r\n    },\r\n\r\n    /**\r\n     * Create a dictionary from a .dic file synchronously.\r\n     *\r\n     * @param {String} file_path The path of the file.\r\n     * @returns The created dictionary\r\n     * @throws An error if the file couldn't be opened\r\n     */  \r\n    _readFileSync: function(file_path) {\r\n        try {\r\n            var text = fs.readFileSync(file_path, 'utf8')\r\n            // Create dictionary and return it.\r\n            var dictionary = new Dictionary(text.split('\\n'));\r\n            return dictionary;\r\n        } catch(err) {\r\n            // Return an error.\r\n            throw new Error(\"The dictionary file could not be read: \" + file_path + \". Error: \" + err);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Unzip a zip file.\r\n     *\r\n     * Each entry in the zip file will be extracted atomically. From the perspective of another\r\n     * process, the unzipped file will either not exist or will be fully unzipped.\r\n     *\r\n     * @param {String} zipPath The path of the zip file.\r\n     * @param {String} destinationDir The directory to unzip into.\r\n     * @throws An error if the file couldn't be unzipped.\r\n     */\r\n    _unzipSync: function(zipPath, destinationDir) {\r\n        // Unzip into a tmp directory.\r\n        var tmpDir = tmp.dirSync({ dir: destinationDir });\r\n        var zip = new Zip(zipPath);\r\n        zip.extractAllTo(tmpDir.name);\r\n\r\n        // Move the unzipped files out of the tmp directory and into the destination directory.\r\n        zip.getEntries().forEach(({ entryName }) => {\r\n            var from = path.join(tmpDir.name, entryName);\r\n            var to = path.join(destinationDir, entryName);\r\n            fs.renameSync(from, to);\r\n        });\r\n\r\n        // Clean up the tmp directory\r\n        tmpDir.removeCallback();\r\n    },\r\n  \r\n    /**\r\n     * Create a dictionary from a .dic file .\r\n     *\r\n     * @param {String} fileName The name of the file from which read the word list.\r\n     * @param {String} folderPath The path to the directory in which the file is located (optional).\r\n     * @return {Object} An instance of the Dictionary class.\r\n     * @throws {Exception} If the dictionary's file can't be found or is invalid.\r\n     */  \r\n    getDictionarySync: function(fileName, folderPath) {\r\n        try{\r\n            // Initialize variables.\r\n            var folder = (!folderPath || typeof folderPath != 'string')? FOLDER_PATH : folderPath;\r\n            var dic_path = folder + '/' + fileName + '.dic';\r\n            var zip_path = folder + '/' + fileName + '.zip';\r\n          \r\n            // Verify if the dictionary file exists.\r\n            if(fs.existsSync(dic_path)) {\r\n                // The file exists, read it.\r\n                var dictionary = SpellChecker._readFileSync(dic_path);\r\n                return dictionary;\r\n            } else {\r\n                // The file do not exists, verify if the ZIP file exists.\r\n                var exists = fs.existsSync(zip_path);\r\n                if(exists) {\r\n                    // The file ZIP exists, unzip it.\r\n                    SpellChecker._unzipSync(zip_path, folder);\r\n                    var dictionary = SpellChecker._readFileSync(dic_path);\r\n                    return dictionary;\r\n                } else {\r\n                    // The ZIP file also doesn't exists, return an error.\r\n                    throw new Error('The dictionary could not be read, no file with the name \"' + fileName + '\" could be found');\r\n                } \r\n            }\r\n        } catch(err) {\r\n            // Throw an error.\r\n            throw new Error('An unexpected error ocurred: ' + err);\r\n        }\r\n    },\r\n    \r\n    /**\r\n     * Reads a UTF8 dictionary file, removes the BOM and \\r characters and sorts the list of words.\r\n     *\r\n     * @param {String} inputPath The path for the input file.\r\n     * @param {String} outputPath The path to output (optional, by default is equals to the input file).\r\n     * @param {Callback} callback A function to invoke after finishing.\r\n     */\r\n    normalizeDictionary: function(inputPath, outputPath /*, callback*/) {\r\n        try{\r\n            // Parses arguments\r\n            if(!outputPath || typeof outputPath != 'string') outputPath = inputPath;\r\n            var callback = arguments.length > 0? arguments[arguments.length - 1] : function() {};\r\n            \r\n            // Verify if the dictionary file exists.\r\n            fs.exists(inputPath, function(exists) {\r\n                if(exists) {\r\n                    // The file exists, read it.\r\n                    fs.readFile(inputPath, 'utf8', function(err, content) {\r\n                        // Check for errors.\r\n                        if (!err) {\r\n                            // Remove BOM and \\r characters.\r\n                            content = stripBOM(content);\r\n                            content = content.replace(/\\r/g, '');\r\n                            \r\n                            // Sort words.\r\n                            var lines = content.split('\\n');      \r\n                            var collator = new Intl.Collator(); // Use this comparator for consider accents and special characters.\r\n                            lines = lines.sort(collator.compare);\r\n                            \r\n                            // Generate output content.\r\n                            var newContent = '';  \r\n                            var first = true;\r\n                            for(var i=0; i<lines.length; i++) {          \r\n                                if(lines[i] != '' && lines[i] != '\\n') {\r\n                                    if(!first) newContent += '\\n';\r\n                                    newContent += lines[i];\r\n                                    first = false;\r\n                                }\r\n                            }\r\n                            \r\n                            // Write output file.\r\n                            fs.writeFile(outputPath, newContent, 'utf8', function(err) {\r\n                                // Return result.\r\n                                callback(err? (\"The output file could not be writted: \" + err) : null, !err);\r\n                            });\r\n                        } else {\r\n                            // Return an error.\r\n                            callback(\"The input file could not be read: \" + err, false);\r\n                        }\r\n                    });\r\n                } else {\r\n                    // Return an error indicating that the file doens't exists.\r\n                    callback(\"The input file does not exists\", false);\r\n                }            \r\n            });\r\n        } catch(err) {\r\n            // Return an error.\r\n            callback('An unexpected error ocurred: ' + err, false);\r\n        }\r\n    }\r\n}\r\n\r\n// Export module.\r\nmodule.exports = SpellChecker;\r\n"]},"metadata":{},"sourceType":"script"}