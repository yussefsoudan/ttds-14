{"ast":null,"code":"var Utils = require(\"./util\");\n\nvar fs = Utils.FileSystem.require(),\n    pth = require(\"path\");\n\nfs.existsSync = fs.existsSync || pth.existsSync;\n\nvar ZipEntry = require(\"./zipEntry\"),\n    ZipFile = require(\"./zipFile\");\n\nvar isWin = /^win/.test(process.platform);\n\nmodule.exports = function (\n/**String*/\ninput) {\n  var _zip = undefined,\n      _filename = \"\";\n\n  if (input && typeof input === \"string\") {\n    // load zip file\n    if (fs.existsSync(input)) {\n      _filename = input;\n      _zip = new ZipFile(input, Utils.Constants.FILE);\n    } else {\n      throw new Error(Utils.Errors.INVALID_FILENAME);\n    }\n  } else if (input && Buffer.isBuffer(input)) {\n    // load buffer\n    _zip = new ZipFile(input, Utils.Constants.BUFFER);\n  } else {\n    // create new zip file\n    _zip = new ZipFile(null, Utils.Constants.NONE);\n  }\n\n  function sanitize(prefix, name) {\n    prefix = pth.resolve(pth.normalize(prefix));\n    var parts = name.split('/');\n\n    for (var i = 0, l = parts.length; i < l; i++) {\n      var path = pth.normalize(pth.join(prefix, parts.slice(i, l).join(pth.sep)));\n\n      if (path.indexOf(prefix) === 0) {\n        return path;\n      }\n    }\n\n    return pth.normalize(pth.join(prefix, pth.basename(name)));\n  }\n\n  function getEntry(\n  /**Object*/\n  entry) {\n    if (entry && _zip) {\n      var item; // If entry was given as a file name\n\n      if (typeof entry === \"string\") item = _zip.getEntry(entry); // if entry was given as a ZipEntry object\n\n      if (typeof entry === \"object\" && typeof entry.entryName !== \"undefined\" && typeof entry.header !== \"undefined\") item = _zip.getEntry(entry.entryName);\n\n      if (item) {\n        return item;\n      }\n    }\n\n    return null;\n  }\n\n  return {\n    /**\r\n     * Extracts the given entry from the archive and returns the content as a Buffer object\r\n     * @param entry ZipEntry object or String with the full path of the entry\r\n     *\r\n     * @return Buffer or Null in case of error\r\n     */\n    readFile: function (\n    /**Object*/\n    entry) {\n      var item = getEntry(entry);\n      return item && item.getData() || null;\n    },\n\n    /**\r\n     * Asynchronous readFile\r\n     * @param entry ZipEntry object or String with the full path of the entry\r\n     * @param callback\r\n     *\r\n     * @return Buffer or Null in case of error\r\n     */\n    readFileAsync: function (\n    /**Object*/\n    entry,\n    /**Function*/\n    callback) {\n      var item = getEntry(entry);\n\n      if (item) {\n        item.getDataAsync(callback);\n      } else {\n        callback(null, \"getEntry failed for:\" + entry);\n      }\n    },\n\n    /**\r\n     * Extracts the given entry from the archive and returns the content as plain text in the given encoding\r\n     * @param entry ZipEntry object or String with the full path of the entry\r\n     * @param encoding Optional. If no encoding is specified utf8 is used\r\n     *\r\n     * @return String\r\n     */\n    readAsText: function (\n    /**Object*/\n    entry,\n    /**String=*/\n    encoding) {\n      var item = getEntry(entry);\n\n      if (item) {\n        var data = item.getData();\n\n        if (data && data.length) {\n          return data.toString(encoding || \"utf8\");\n        }\n      }\n\n      return \"\";\n    },\n\n    /**\r\n     * Asynchronous readAsText\r\n     * @param entry ZipEntry object or String with the full path of the entry\r\n     * @param callback\r\n     * @param encoding Optional. If no encoding is specified utf8 is used\r\n     *\r\n     * @return String\r\n     */\n    readAsTextAsync: function (\n    /**Object*/\n    entry,\n    /**Function*/\n    callback,\n    /**String=*/\n    encoding) {\n      var item = getEntry(entry);\n\n      if (item) {\n        item.getDataAsync(function (data, err) {\n          if (err) {\n            callback(data, err);\n            return;\n          }\n\n          if (data && data.length) {\n            callback(data.toString(encoding || \"utf8\"));\n          } else {\n            callback(\"\");\n          }\n        });\n      } else {\n        callback(\"\");\n      }\n    },\n\n    /**\r\n     * Remove the entry from the file or the entry and all it's nested directories and files if the given entry is a directory\r\n     *\r\n     * @param entry\r\n     */\n    deleteFile: function (\n    /**Object*/\n    entry) {\n      // @TODO: test deleteFile\n      var item = getEntry(entry);\n\n      if (item) {\n        _zip.deleteEntry(item.entryName);\n      }\n    },\n\n    /**\r\n     * Adds a comment to the zip. The zip must be rewritten after adding the comment.\r\n     *\r\n     * @param comment\r\n     */\n    addZipComment: function (\n    /**String*/\n    comment) {\n      // @TODO: test addZipComment\n      _zip.comment = comment;\n    },\n\n    /**\r\n     * Returns the zip comment\r\n     *\r\n     * @return String\r\n     */\n    getZipComment: function () {\n      return _zip.comment || '';\n    },\n\n    /**\r\n     * Adds a comment to a specified zipEntry. The zip must be rewritten after adding the comment\r\n     * The comment cannot exceed 65535 characters in length\r\n     *\r\n     * @param entry\r\n     * @param comment\r\n     */\n    addZipEntryComment: function (\n    /**Object*/\n    entry,\n    /**String*/\n    comment) {\n      var item = getEntry(entry);\n\n      if (item) {\n        item.comment = comment;\n      }\n    },\n\n    /**\r\n     * Returns the comment of the specified entry\r\n     *\r\n     * @param entry\r\n     * @return String\r\n     */\n    getZipEntryComment: function (\n    /**Object*/\n    entry) {\n      var item = getEntry(entry);\n\n      if (item) {\n        return item.comment || '';\n      }\n\n      return '';\n    },\n\n    /**\r\n     * Updates the content of an existing entry inside the archive. The zip must be rewritten after updating the content\r\n     *\r\n     * @param entry\r\n     * @param content\r\n     */\n    updateFile: function (\n    /**Object*/\n    entry,\n    /**Buffer*/\n    content) {\n      var item = getEntry(entry);\n\n      if (item) {\n        item.setData(content);\n      }\n    },\n\n    /**\r\n     * Adds a file from the disk to the archive\r\n     *\r\n     * @param localPath File to add to zip\r\n     * @param zipPath Optional path inside the zip\r\n     * @param zipName Optional name for the file\r\n     */\n    addLocalFile: function (\n    /**String*/\n    localPath,\n    /**String=*/\n    zipPath,\n    /**String=*/\n    zipName) {\n      if (fs.existsSync(localPath)) {\n        if (zipPath) {\n          zipPath = zipPath.split(\"\\\\\").join(\"/\");\n\n          if (zipPath.charAt(zipPath.length - 1) !== \"/\") {\n            zipPath += \"/\";\n          }\n        } else {\n          zipPath = \"\";\n        }\n\n        var p = localPath.split(\"\\\\\").join(\"/\").split(\"/\").pop();\n\n        if (zipName) {\n          this.addFile(zipPath + zipName, fs.readFileSync(localPath), \"\", 0);\n        } else {\n          this.addFile(zipPath + p, fs.readFileSync(localPath), \"\", 0);\n        }\n      } else {\n        throw new Error(Utils.Errors.FILE_NOT_FOUND.replace(\"%s\", localPath));\n      }\n    },\n\n    /**\r\n     * Adds a local directory and all its nested files and directories to the archive\r\n     *\r\n     * @param localPath\r\n     * @param zipPath optional path inside zip\r\n     * @param filter optional RegExp or Function if files match will\r\n     *               be included.\r\n     */\n    addLocalFolder: function (\n    /**String*/\n    localPath,\n    /**String=*/\n    zipPath,\n    /**=RegExp|Function*/\n    filter) {\n      if (filter === undefined) {\n        filter = function () {\n          return true;\n        };\n      } else if (filter instanceof RegExp) {\n        filter = function (filter) {\n          return function (filename) {\n            return filter.test(filename);\n          };\n        }(filter);\n      }\n\n      if (zipPath) {\n        zipPath = zipPath.split(\"\\\\\").join(\"/\");\n\n        if (zipPath.charAt(zipPath.length - 1) !== \"/\") {\n          zipPath += \"/\";\n        }\n      } else {\n        zipPath = \"\";\n      } // normalize the path first\n\n\n      localPath = pth.normalize(localPath);\n      localPath = localPath.split(\"\\\\\").join(\"/\"); //windows fix\n\n      if (localPath.charAt(localPath.length - 1) !== \"/\") localPath += \"/\";\n\n      if (fs.existsSync(localPath)) {\n        var items = Utils.findFiles(localPath),\n            self = this;\n\n        if (items.length) {\n          items.forEach(function (path) {\n            var p = path.split(\"\\\\\").join(\"/\").replace(new RegExp(localPath.replace(/(\\(|\\)|\\$)/g, '\\\\$1'), 'i'), \"\"); //windows fix\n\n            if (filter(p)) {\n              if (p.charAt(p.length - 1) !== \"/\") {\n                self.addFile(zipPath + p, fs.readFileSync(path), \"\", 0);\n              } else {\n                self.addFile(zipPath + p, Buffer.alloc(0), \"\", 0);\n              }\n            }\n          });\n        }\n      } else {\n        throw new Error(Utils.Errors.FILE_NOT_FOUND.replace(\"%s\", localPath));\n      }\n    },\n\n    /**\r\n     * Asynchronous addLocalFile\r\n     * @param localPath\r\n     * @param callback\r\n     * @param zipPath optional path inside zip\r\n     * @param filter optional RegExp or Function if files match will\r\n     *               be included.\r\n     */\n    addLocalFolderAsync: function (\n    /*String*/\n    localPath,\n    /*Function*/\n    callback,\n    /*String*/\n    zipPath,\n    /*RegExp|Function*/\n    filter) {\n      if (filter === undefined) {\n        filter = function () {\n          return true;\n        };\n      } else if (filter instanceof RegExp) {\n        filter = function (filter) {\n          return function (filename) {\n            return filter.test(filename);\n          };\n        }(filter);\n      }\n\n      if (zipPath) {\n        zipPath = zipPath.split(\"\\\\\").join(\"/\");\n\n        if (zipPath.charAt(zipPath.length - 1) !== \"/\") {\n          zipPath += \"/\";\n        }\n      } else {\n        zipPath = \"\";\n      } // normalize the path first\n\n\n      localPath = pth.normalize(localPath);\n      localPath = localPath.split(\"\\\\\").join(\"/\"); //windows fix\n\n      if (localPath.charAt(localPath.length - 1) !== \"/\") localPath += \"/\";\n      var self = this;\n      fs.open(localPath, 'r', function (err, fd) {\n        if (err && err.code === 'ENOENT') {\n          callback(undefined, Utils.Errors.FILE_NOT_FOUND.replace(\"%s\", localPath));\n        } else if (err) {\n          callback(undefined, err);\n        } else {\n          var items = Utils.findFiles(localPath);\n          var i = -1;\n\n          var next = function () {\n            i += 1;\n\n            if (i < items.length) {\n              var p = items[i].split(\"\\\\\").join(\"/\").replace(new RegExp(localPath.replace(/(\\(|\\))/g, '\\\\$1'), 'i'), \"\"); //windows fix\n\n              p = p.normalize('NFD').replace(/[\\u0300-\\u036f]/g, '').replace(/[^\\x20-\\x7E]/g, ''); // accent fix\n\n              if (filter(p)) {\n                if (p.charAt(p.length - 1) !== \"/\") {\n                  fs.readFile(items[i], function (err, data) {\n                    if (err) {\n                      callback(undefined, err);\n                    } else {\n                      self.addFile(zipPath + p, data, '', 0);\n                      next();\n                    }\n                  });\n                } else {\n                  self.addFile(zipPath + p, Buffer.alloc(0), \"\", 0);\n                  next();\n                }\n              } else {\n                next();\n              }\n            } else {\n              callback(true, undefined);\n            }\n          };\n\n          next();\n        }\n      });\n    },\n\n    /**\r\n     * Allows you to create a entry (file or directory) in the zip file.\r\n     * If you want to create a directory the entryName must end in / and a null buffer should be provided.\r\n     * Comment and attributes are optional\r\n     *\r\n     * @param entryName\r\n     * @param content\r\n     * @param comment\r\n     * @param attr\r\n     */\n    addFile: function (\n    /**String*/\n    entryName,\n    /**Buffer*/\n    content,\n    /**String*/\n    comment,\n    /**Number*/\n    attr) {\n      var entry = new ZipEntry();\n      entry.entryName = entryName;\n      entry.comment = comment || \"\";\n\n      if (!attr) {\n        if (entry.isDirectory) {\n          attr = 0o40755 << 16 | 0x10; // (permissions drwxr-xr-x) + (MS-DOS directory flag)\n        } else {\n          attr = 0o644 << 16; // permissions -r-wr--r--\n        }\n      }\n\n      entry.attr = attr;\n      entry.setData(content);\n\n      _zip.setEntry(entry);\n    },\n\n    /**\r\n     * Returns an array of ZipEntry objects representing the files and folders inside the archive\r\n     *\r\n     * @return Array\r\n     */\n    getEntries: function () {\n      if (_zip) {\n        return _zip.entries;\n      } else {\n        return [];\n      }\n    },\n\n    /**\r\n     * Returns a ZipEntry object representing the file or folder specified by ``name``.\r\n     *\r\n     * @param name\r\n     * @return ZipEntry\r\n     */\n    getEntry: function (\n    /**String*/\n    name) {\n      return getEntry(name);\n    },\n    getEntryCount: function () {\n      return _zip.getEntryCount();\n    },\n    forEach: function (callback) {\n      return _zip.forEach(callback);\n    },\n\n    /**\r\n     * Extracts the given entry to the given targetPath\r\n     * If the entry is a directory inside the archive, the entire directory and it's subdirectories will be extracted\r\n     *\r\n     * @param entry ZipEntry object or String with the full path of the entry\r\n     * @param targetPath Target folder where to write the file\r\n     * @param maintainEntryPath If maintainEntryPath is true and the entry is inside a folder, the entry folder\r\n     *                          will be created in targetPath as well. Default is TRUE\r\n     * @param overwrite If the file already exists at the target path, the file will be overwriten if this is true.\r\n     *                  Default is FALSE\r\n     *\r\n     * @return Boolean\r\n     */\n    extractEntryTo: function (\n    /**Object*/\n    entry,\n    /**String*/\n    targetPath,\n    /**Boolean*/\n    maintainEntryPath,\n    /**Boolean*/\n    overwrite) {\n      overwrite = overwrite || false;\n      maintainEntryPath = typeof maintainEntryPath === \"undefined\" ? true : maintainEntryPath;\n      var item = getEntry(entry);\n\n      if (!item) {\n        throw new Error(Utils.Errors.NO_ENTRY);\n      }\n\n      var entryName = item.entryName;\n      var target = sanitize(targetPath, maintainEntryPath ? entryName : pth.basename(entryName));\n\n      if (item.isDirectory) {\n        target = pth.resolve(target, \"..\");\n\n        var children = _zip.getEntryChildren(item);\n\n        children.forEach(function (child) {\n          if (child.isDirectory) return;\n          var content = child.getData();\n\n          if (!content) {\n            throw new Error(Utils.Errors.CANT_EXTRACT_FILE);\n          }\n\n          var childName = sanitize(targetPath, maintainEntryPath ? child.entryName : pth.basename(child.entryName));\n          Utils.writeFileTo(childName, content, overwrite);\n        });\n        return true;\n      }\n\n      var content = item.getData();\n      if (!content) throw new Error(Utils.Errors.CANT_EXTRACT_FILE);\n\n      if (fs.existsSync(target) && !overwrite) {\n        throw new Error(Utils.Errors.CANT_OVERRIDE);\n      }\n\n      Utils.writeFileTo(target, content, overwrite);\n      return true;\n    },\n\n    /**\r\n     * Test the archive\r\n     *\r\n     */\n    test: function () {\n      if (!_zip) {\n        return false;\n      }\n\n      for (var entry in _zip.entries) {\n        try {\n          if (entry.isDirectory) {\n            continue;\n          }\n\n          var content = _zip.entries[entry].getData();\n\n          if (!content) {\n            return false;\n          }\n        } catch (err) {\n          return false;\n        }\n      }\n\n      return true;\n    },\n\n    /**\r\n     * Extracts the entire archive to the given location\r\n     *\r\n     * @param targetPath Target location\r\n     * @param overwrite If the file already exists at the target path, the file will be overwriten if this is true.\r\n     *                  Default is FALSE\r\n     */\n    extractAllTo: function (\n    /**String*/\n    targetPath,\n    /**Boolean*/\n    overwrite) {\n      overwrite = overwrite || false;\n\n      if (!_zip) {\n        throw new Error(Utils.Errors.NO_ZIP);\n      }\n\n      _zip.entries.forEach(function (entry) {\n        var entryName = sanitize(targetPath, entry.entryName.toString());\n\n        if (entry.isDirectory) {\n          Utils.makeDir(entryName);\n          return;\n        }\n\n        var content = entry.getData();\n\n        if (!content) {\n          throw new Error(Utils.Errors.CANT_EXTRACT_FILE);\n        }\n\n        Utils.writeFileTo(entryName, content, overwrite);\n\n        try {\n          fs.utimesSync(entryName, entry.header.time, entry.header.time);\n        } catch (err) {\n          throw new Error(Utils.Errors.CANT_EXTRACT_FILE);\n        }\n      });\n    },\n\n    /**\r\n     * Asynchronous extractAllTo\r\n     *\r\n     * @param targetPath Target location\r\n     * @param overwrite If the file already exists at the target path, the file will be overwriten if this is true.\r\n     *                  Default is FALSE\r\n     * @param callback\r\n     */\n    extractAllToAsync: function (\n    /**String*/\n    targetPath,\n    /**Boolean*/\n    overwrite,\n    /**Function*/\n    callback) {\n      if (!callback) {\n        callback = function () {};\n      }\n\n      overwrite = overwrite || false;\n\n      if (!_zip) {\n        callback(new Error(Utils.Errors.NO_ZIP));\n        return;\n      }\n\n      var entries = _zip.entries;\n      var i = entries.length;\n      entries.forEach(function (entry) {\n        if (i <= 0) return; // Had an error already\n\n        var entryName = pth.normalize(entry.entryName.toString());\n\n        if (entry.isDirectory) {\n          Utils.makeDir(sanitize(targetPath, entryName));\n          if (--i === 0) callback(undefined);\n          return;\n        }\n\n        entry.getDataAsync(function (content, err) {\n          if (i <= 0) return;\n\n          if (err) {\n            callback(new Error(err));\n            return;\n          }\n\n          if (!content) {\n            i = 0;\n            callback(new Error(Utils.Errors.CANT_EXTRACT_FILE));\n            return;\n          }\n\n          Utils.writeFileToAsync(sanitize(targetPath, entryName), content, overwrite, function (succ) {\n            try {\n              fs.utimesSync(pth.resolve(targetPath, entryName), entry.header.time, entry.header.time);\n            } catch (err) {\n              callback(new Error('Unable to set utimes'));\n            }\n\n            if (i <= 0) return;\n\n            if (!succ) {\n              i = 0;\n              callback(new Error('Unable to write'));\n              return;\n            }\n\n            if (--i === 0) callback(undefined);\n          });\n        });\n      });\n    },\n\n    /**\r\n     * Writes the newly created zip file to disk at the specified location or if a zip was opened and no ``targetFileName`` is provided, it will overwrite the opened zip\r\n     *\r\n     * @param targetFileName\r\n     * @param callback\r\n     */\n    writeZip: function (\n    /**String*/\n    targetFileName,\n    /**Function*/\n    callback) {\n      if (arguments.length === 1) {\n        if (typeof targetFileName === \"function\") {\n          callback = targetFileName;\n          targetFileName = \"\";\n        }\n      }\n\n      if (!targetFileName && _filename) {\n        targetFileName = _filename;\n      }\n\n      if (!targetFileName) return;\n\n      var zipData = _zip.compressToBuffer();\n\n      if (zipData) {\n        var ok = Utils.writeFileTo(targetFileName, zipData, true);\n        if (typeof callback === 'function') callback(!ok ? new Error(\"failed\") : null, \"\");\n      }\n    },\n\n    /**\r\n     * Returns the content of the entire zip file as a Buffer object\r\n     *\r\n     * @return Buffer\r\n     */\n    toBuffer: function (\n    /**Function=*/\n    onSuccess,\n    /**Function=*/\n    onFail,\n    /**Function=*/\n    onItemStart,\n    /**Function=*/\n    onItemEnd) {\n      this.valueOf = 2;\n\n      if (typeof onSuccess === \"function\") {\n        _zip.toAsyncBuffer(onSuccess, onFail, onItemStart, onItemEnd);\n\n        return null;\n      }\n\n      return _zip.compressToBuffer();\n    }\n  };\n};","map":{"version":3,"sources":["/Users/yussefsoudan/Studies/Uni/year-4-cs/TTDS/CW3/ttds-14/website/book-search-client/node_modules/adm-zip/adm-zip.js"],"names":["Utils","require","fs","FileSystem","pth","existsSync","ZipEntry","ZipFile","isWin","test","process","platform","module","exports","input","_zip","undefined","_filename","Constants","FILE","Error","Errors","INVALID_FILENAME","Buffer","isBuffer","BUFFER","NONE","sanitize","prefix","name","resolve","normalize","parts","split","i","l","length","path","join","slice","sep","indexOf","basename","getEntry","entry","item","entryName","header","readFile","getData","readFileAsync","callback","getDataAsync","readAsText","encoding","data","toString","readAsTextAsync","err","deleteFile","deleteEntry","addZipComment","comment","getZipComment","addZipEntryComment","getZipEntryComment","updateFile","content","setData","addLocalFile","localPath","zipPath","zipName","charAt","p","pop","addFile","readFileSync","FILE_NOT_FOUND","replace","addLocalFolder","filter","RegExp","filename","items","findFiles","self","forEach","alloc","addLocalFolderAsync","open","fd","code","next","attr","isDirectory","setEntry","getEntries","entries","getEntryCount","extractEntryTo","targetPath","maintainEntryPath","overwrite","NO_ENTRY","target","children","getEntryChildren","child","CANT_EXTRACT_FILE","childName","writeFileTo","CANT_OVERRIDE","extractAllTo","NO_ZIP","makeDir","utimesSync","time","extractAllToAsync","writeFileToAsync","succ","writeZip","targetFileName","arguments","zipData","compressToBuffer","ok","toBuffer","onSuccess","onFail","onItemStart","onItemEnd","valueOf","toAsyncBuffer"],"mappings":"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","sourcesContent":["var Utils = require(\"./util\");\r\nvar fs = Utils.FileSystem.require(),\r\n\tpth = require(\"path\");\r\n\r\nfs.existsSync = fs.existsSync || pth.existsSync;\r\n\r\nvar ZipEntry = require(\"./zipEntry\"),\r\n\tZipFile = require(\"./zipFile\");\r\n\r\nvar isWin = /^win/.test(process.platform);\r\n\r\n\r\nmodule.exports = function (/**String*/input) {\r\n\tvar _zip = undefined,\r\n\t\t_filename = \"\";\r\n\r\n\tif (input && typeof input === \"string\") { // load zip file\r\n\t\tif (fs.existsSync(input)) {\r\n\t\t\t_filename = input;\r\n\t\t\t_zip = new ZipFile(input, Utils.Constants.FILE);\r\n\t\t} else {\r\n\t\t\tthrow new Error(Utils.Errors.INVALID_FILENAME);\r\n\t\t}\r\n\t} else if (input && Buffer.isBuffer(input)) { // load buffer\r\n\t\t_zip = new ZipFile(input, Utils.Constants.BUFFER);\r\n\t} else { // create new zip file\r\n\t\t_zip = new ZipFile(null, Utils.Constants.NONE);\r\n\t}\r\n\r\n\tfunction sanitize(prefix, name) {\r\n\t\tprefix = pth.resolve(pth.normalize(prefix));\r\n\t\tvar parts = name.split('/');\r\n\t\tfor (var i = 0, l = parts.length; i < l; i++) {\r\n\t\t\tvar path = pth.normalize(pth.join(prefix, parts.slice(i, l).join(pth.sep)));\r\n\t\t\tif (path.indexOf(prefix) === 0) {\r\n\t\t\t\treturn path;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn pth.normalize(pth.join(prefix, pth.basename(name)));\r\n\t}\r\n\r\n\tfunction getEntry(/**Object*/entry) {\r\n\t\tif (entry && _zip) {\r\n\t\t\tvar item;\r\n\t\t\t// If entry was given as a file name\r\n\t\t\tif (typeof entry === \"string\")\r\n\t\t\t\titem = _zip.getEntry(entry);\r\n\t\t\t// if entry was given as a ZipEntry object\r\n\t\t\tif (typeof entry === \"object\" && typeof entry.entryName !== \"undefined\" && typeof entry.header !== \"undefined\")\r\n\t\t\t\titem = _zip.getEntry(entry.entryName);\r\n\r\n\t\t\tif (item) {\r\n\t\t\t\treturn item;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn null;\r\n\t}\r\n\r\n\treturn {\r\n\t\t/**\r\n\t\t * Extracts the given entry from the archive and returns the content as a Buffer object\r\n\t\t * @param entry ZipEntry object or String with the full path of the entry\r\n\t\t *\r\n\t\t * @return Buffer or Null in case of error\r\n\t\t */\r\n\t\treadFile: function (/**Object*/entry) {\r\n\t\t\tvar item = getEntry(entry);\r\n\t\t\treturn item && item.getData() || null;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Asynchronous readFile\r\n\t\t * @param entry ZipEntry object or String with the full path of the entry\r\n\t\t * @param callback\r\n\t\t *\r\n\t\t * @return Buffer or Null in case of error\r\n\t\t */\r\n\t\treadFileAsync: function (/**Object*/entry, /**Function*/callback) {\r\n\t\t\tvar item = getEntry(entry);\r\n\t\t\tif (item) {\r\n\t\t\t\titem.getDataAsync(callback);\r\n\t\t\t} else {\r\n\t\t\t\tcallback(null, \"getEntry failed for:\" + entry)\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Extracts the given entry from the archive and returns the content as plain text in the given encoding\r\n\t\t * @param entry ZipEntry object or String with the full path of the entry\r\n\t\t * @param encoding Optional. If no encoding is specified utf8 is used\r\n\t\t *\r\n\t\t * @return String\r\n\t\t */\r\n\t\treadAsText: function (/**Object*/entry, /**String=*/encoding) {\r\n\t\t\tvar item = getEntry(entry);\r\n\t\t\tif (item) {\r\n\t\t\t\tvar data = item.getData();\r\n\t\t\t\tif (data && data.length) {\r\n\t\t\t\t\treturn data.toString(encoding || \"utf8\");\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn \"\";\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Asynchronous readAsText\r\n\t\t * @param entry ZipEntry object or String with the full path of the entry\r\n\t\t * @param callback\r\n\t\t * @param encoding Optional. If no encoding is specified utf8 is used\r\n\t\t *\r\n\t\t * @return String\r\n\t\t */\r\n\t\treadAsTextAsync: function (/**Object*/entry, /**Function*/callback, /**String=*/encoding) {\r\n\t\t\tvar item = getEntry(entry);\r\n\t\t\tif (item) {\r\n\t\t\t\titem.getDataAsync(function (data, err) {\r\n\t\t\t\t\tif (err) {\r\n\t\t\t\t\t\tcallback(data, err);\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (data && data.length) {\r\n\t\t\t\t\t\tcallback(data.toString(encoding || \"utf8\"));\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tcallback(\"\");\r\n\t\t\t\t\t}\r\n\t\t\t\t})\r\n\t\t\t} else {\r\n\t\t\t\tcallback(\"\");\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Remove the entry from the file or the entry and all it's nested directories and files if the given entry is a directory\r\n\t\t *\r\n\t\t * @param entry\r\n\t\t */\r\n\t\tdeleteFile: function (/**Object*/entry) { // @TODO: test deleteFile\r\n\t\t\tvar item = getEntry(entry);\r\n\t\t\tif (item) {\r\n\t\t\t\t_zip.deleteEntry(item.entryName);\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Adds a comment to the zip. The zip must be rewritten after adding the comment.\r\n\t\t *\r\n\t\t * @param comment\r\n\t\t */\r\n\t\taddZipComment: function (/**String*/comment) { // @TODO: test addZipComment\r\n\t\t\t_zip.comment = comment;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Returns the zip comment\r\n\t\t *\r\n\t\t * @return String\r\n\t\t */\r\n\t\tgetZipComment: function () {\r\n\t\t\treturn _zip.comment || '';\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Adds a comment to a specified zipEntry. The zip must be rewritten after adding the comment\r\n\t\t * The comment cannot exceed 65535 characters in length\r\n\t\t *\r\n\t\t * @param entry\r\n\t\t * @param comment\r\n\t\t */\r\n\t\taddZipEntryComment: function (/**Object*/entry, /**String*/comment) {\r\n\t\t\tvar item = getEntry(entry);\r\n\t\t\tif (item) {\r\n\t\t\t\titem.comment = comment;\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Returns the comment of the specified entry\r\n\t\t *\r\n\t\t * @param entry\r\n\t\t * @return String\r\n\t\t */\r\n\t\tgetZipEntryComment: function (/**Object*/entry) {\r\n\t\t\tvar item = getEntry(entry);\r\n\t\t\tif (item) {\r\n\t\t\t\treturn item.comment || '';\r\n\t\t\t}\r\n\t\t\treturn ''\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Updates the content of an existing entry inside the archive. The zip must be rewritten after updating the content\r\n\t\t *\r\n\t\t * @param entry\r\n\t\t * @param content\r\n\t\t */\r\n\t\tupdateFile: function (/**Object*/entry, /**Buffer*/content) {\r\n\t\t\tvar item = getEntry(entry);\r\n\t\t\tif (item) {\r\n\t\t\t\titem.setData(content);\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Adds a file from the disk to the archive\r\n\t\t *\r\n\t\t * @param localPath File to add to zip\r\n\t\t * @param zipPath Optional path inside the zip\r\n\t\t * @param zipName Optional name for the file\r\n\t\t */\r\n\t\taddLocalFile: function (/**String*/localPath, /**String=*/zipPath, /**String=*/zipName) {\r\n\t\t\tif (fs.existsSync(localPath)) {\r\n\t\t\t\tif (zipPath) {\r\n\t\t\t\t\tzipPath = zipPath.split(\"\\\\\").join(\"/\");\r\n\t\t\t\t\tif (zipPath.charAt(zipPath.length - 1) !== \"/\") {\r\n\t\t\t\t\t\tzipPath += \"/\";\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tzipPath = \"\";\r\n\t\t\t\t}\r\n\t\t\t\tvar p = localPath.split(\"\\\\\").join(\"/\").split(\"/\").pop();\r\n\r\n\t\t\t\tif (zipName) {\r\n\t\t\t\t\tthis.addFile(zipPath + zipName, fs.readFileSync(localPath), \"\", 0)\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthis.addFile(zipPath + p, fs.readFileSync(localPath), \"\", 0)\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tthrow new Error(Utils.Errors.FILE_NOT_FOUND.replace(\"%s\", localPath));\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Adds a local directory and all its nested files and directories to the archive\r\n\t\t *\r\n\t\t * @param localPath\r\n\t\t * @param zipPath optional path inside zip\r\n\t\t * @param filter optional RegExp or Function if files match will\r\n\t\t *               be included.\r\n\t\t */\r\n\t\taddLocalFolder: function (/**String*/localPath, /**String=*/zipPath, /**=RegExp|Function*/filter) {\r\n\t\t\tif (filter === undefined) {\r\n\t\t\t\tfilter = function () {\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t};\r\n\t\t\t} else if (filter instanceof RegExp) {\r\n\t\t\t\tfilter = function (filter) {\r\n\t\t\t\t\treturn function (filename) {\r\n\t\t\t\t\t\treturn filter.test(filename);\r\n\t\t\t\t\t}\r\n\t\t\t\t}(filter);\r\n\t\t\t}\r\n\r\n\t\t\tif (zipPath) {\r\n\t\t\t\tzipPath = zipPath.split(\"\\\\\").join(\"/\");\r\n\t\t\t\tif (zipPath.charAt(zipPath.length - 1) !== \"/\") {\r\n\t\t\t\t\tzipPath += \"/\";\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tzipPath = \"\";\r\n\t\t\t}\r\n\t\t\t// normalize the path first\r\n\t\t\tlocalPath = pth.normalize(localPath);\r\n\t\t\tlocalPath = localPath.split(\"\\\\\").join(\"/\"); //windows fix\r\n\t\t\tif (localPath.charAt(localPath.length - 1) !== \"/\")\r\n\t\t\t\tlocalPath += \"/\";\r\n\r\n\t\t\tif (fs.existsSync(localPath)) {\r\n\r\n\t\t\t\tvar items = Utils.findFiles(localPath),\r\n\t\t\t\t\tself = this;\r\n\r\n\t\t\t\tif (items.length) {\r\n\t\t\t\t\titems.forEach(function (path) {\r\n\t\t\t\t\t\tvar p = path.split(\"\\\\\").join(\"/\").replace(new RegExp(localPath.replace(/(\\(|\\)|\\$)/g, '\\\\$1'), 'i'), \"\"); //windows fix\r\n\t\t\t\t\t\tif (filter(p)) {\r\n\t\t\t\t\t\t\tif (p.charAt(p.length - 1) !== \"/\") {\r\n\t\t\t\t\t\t\t\tself.addFile(zipPath + p, fs.readFileSync(path), \"\", 0)\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tself.addFile(zipPath + p, Buffer.alloc(0), \"\", 0)\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tthrow new Error(Utils.Errors.FILE_NOT_FOUND.replace(\"%s\", localPath));\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Asynchronous addLocalFile\r\n\t\t * @param localPath\r\n\t\t * @param callback\r\n\t\t * @param zipPath optional path inside zip\r\n\t\t * @param filter optional RegExp or Function if files match will\r\n\t\t *               be included.\r\n\t\t */\r\n\t\taddLocalFolderAsync: function (/*String*/localPath, /*Function*/callback, /*String*/zipPath, /*RegExp|Function*/filter) {\r\n\t\t\tif (filter === undefined) {\r\n\t\t\t\tfilter = function () {\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t};\r\n\t\t\t} else if (filter instanceof RegExp) {\r\n\t\t\t\tfilter = function (filter) {\r\n\t\t\t\t\treturn function (filename) {\r\n\t\t\t\t\t\treturn filter.test(filename);\r\n\t\t\t\t\t}\r\n\t\t\t\t}(filter);\r\n\t\t\t}\r\n\r\n\t\t\tif (zipPath) {\r\n\t\t\t\tzipPath = zipPath.split(\"\\\\\").join(\"/\");\r\n\t\t\t\tif (zipPath.charAt(zipPath.length - 1) !== \"/\") {\r\n\t\t\t\t\tzipPath += \"/\";\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tzipPath = \"\";\r\n\t\t\t}\r\n\t\t\t// normalize the path first\r\n\t\t\tlocalPath = pth.normalize(localPath);\r\n\t\t\tlocalPath = localPath.split(\"\\\\\").join(\"/\"); //windows fix\r\n\t\t\tif (localPath.charAt(localPath.length - 1) !== \"/\")\r\n\t\t\t\tlocalPath += \"/\";\r\n\r\n\t\t\tvar self = this;\r\n\t\t\tfs.open(localPath, 'r', function (err, fd) {\r\n\t\t\t\tif (err && err.code === 'ENOENT') {\r\n\t\t\t\t\tcallback(undefined, Utils.Errors.FILE_NOT_FOUND.replace(\"%s\", localPath));\r\n\t\t\t\t} else if (err) {\r\n\t\t\t\t\tcallback(undefined, err);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tvar items = Utils.findFiles(localPath);\r\n\t\t\t\t\tvar i = -1;\r\n\r\n\t\t\t\t\tvar next = function () {\r\n\t\t\t\t\t\ti += 1;\r\n\t\t\t\t\t\tif (i < items.length) {\r\n\t\t\t\t\t\t\tvar p = items[i].split(\"\\\\\").join(\"/\").replace(new RegExp(localPath.replace(/(\\(|\\))/g, '\\\\$1'), 'i'), \"\"); //windows fix\r\n\t\t\t\t\t\t\tp = p.normalize('NFD').replace(/[\\u0300-\\u036f]/g, '').replace(/[^\\x20-\\x7E]/g, '') // accent fix\r\n\t\t\t\t\t\t\tif (filter(p)) {\r\n\t\t\t\t\t\t\t\tif (p.charAt(p.length - 1) !== \"/\") {\r\n\t\t\t\t\t\t\t\t\tfs.readFile(items[i], function (err, data) {\r\n\t\t\t\t\t\t\t\t\t\tif (err) {\r\n\t\t\t\t\t\t\t\t\t\t\tcallback(undefined, err);\r\n\t\t\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t\t\tself.addFile(zipPath + p, data, '', 0);\r\n\t\t\t\t\t\t\t\t\t\t\tnext();\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t})\r\n\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\tself.addFile(zipPath + p, Buffer.alloc(0), \"\", 0);\r\n\t\t\t\t\t\t\t\t\tnext();\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tnext();\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tcallback(true, undefined);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tnext();\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Allows you to create a entry (file or directory) in the zip file.\r\n\t\t * If you want to create a directory the entryName must end in / and a null buffer should be provided.\r\n\t\t * Comment and attributes are optional\r\n\t\t *\r\n\t\t * @param entryName\r\n\t\t * @param content\r\n\t\t * @param comment\r\n\t\t * @param attr\r\n\t\t */\r\n\t\taddFile: function (/**String*/entryName, /**Buffer*/content, /**String*/comment, /**Number*/attr) {\r\n\t\t\tvar entry = new ZipEntry();\r\n\t\t\tentry.entryName = entryName;\r\n\t\t\tentry.comment = comment || \"\";\r\n\r\n\t\t\tif (!attr) {\r\n\t\t\t\tif (entry.isDirectory) {\r\n\t\t\t\t\tattr = (0o40755 << 16) | 0x10; // (permissions drwxr-xr-x) + (MS-DOS directory flag)\r\n\t\t\t\t} else {\r\n\t\t\t\t\tattr = 0o644 << 16; // permissions -r-wr--r--\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tentry.attr = attr;\r\n\r\n\t\t\tentry.setData(content);\r\n\t\t\t_zip.setEntry(entry);\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Returns an array of ZipEntry objects representing the files and folders inside the archive\r\n\t\t *\r\n\t\t * @return Array\r\n\t\t */\r\n\t\tgetEntries: function () {\r\n\t\t\tif (_zip) {\r\n\t\t\t\treturn _zip.entries;\r\n\t\t\t} else {\r\n\t\t\t\treturn [];\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Returns a ZipEntry object representing the file or folder specified by ``name``.\r\n\t\t *\r\n\t\t * @param name\r\n\t\t * @return ZipEntry\r\n\t\t */\r\n\t\tgetEntry: function (/**String*/name) {\r\n\t\t\treturn getEntry(name);\r\n\t\t},\r\n\r\n\t\tgetEntryCount: function() {\r\n\t\t\treturn _zip.getEntryCount();\r\n\t\t},\r\n\r\n\t\tforEach: function(callback) {\r\n\t\t\treturn _zip.forEach(callback);\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Extracts the given entry to the given targetPath\r\n\t\t * If the entry is a directory inside the archive, the entire directory and it's subdirectories will be extracted\r\n\t\t *\r\n\t\t * @param entry ZipEntry object or String with the full path of the entry\r\n\t\t * @param targetPath Target folder where to write the file\r\n\t\t * @param maintainEntryPath If maintainEntryPath is true and the entry is inside a folder, the entry folder\r\n\t\t *                          will be created in targetPath as well. Default is TRUE\r\n\t\t * @param overwrite If the file already exists at the target path, the file will be overwriten if this is true.\r\n\t\t *                  Default is FALSE\r\n\t\t *\r\n\t\t * @return Boolean\r\n\t\t */\r\n\t\textractEntryTo: function (/**Object*/entry, /**String*/targetPath, /**Boolean*/maintainEntryPath, /**Boolean*/overwrite) {\r\n\t\t\toverwrite = overwrite || false;\r\n\t\t\tmaintainEntryPath = typeof maintainEntryPath === \"undefined\" ? true : maintainEntryPath;\r\n\r\n\t\t\tvar item = getEntry(entry);\r\n\t\t\tif (!item) {\r\n\t\t\t\tthrow new Error(Utils.Errors.NO_ENTRY);\r\n\t\t\t}\r\n\r\n\t\t\tvar entryName = item.entryName;\r\n\r\n\t\t\tvar target = sanitize(targetPath, maintainEntryPath ? entryName : pth.basename(entryName));\r\n\r\n\t\t\tif (item.isDirectory) {\r\n\t\t\t\ttarget = pth.resolve(target, \"..\");\r\n\t\t\t\tvar children = _zip.getEntryChildren(item);\r\n\t\t\t\tchildren.forEach(function (child) {\r\n\t\t\t\t\tif (child.isDirectory) return;\r\n\t\t\t\t\tvar content = child.getData();\r\n\t\t\t\t\tif (!content) {\r\n\t\t\t\t\t\tthrow new Error(Utils.Errors.CANT_EXTRACT_FILE);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvar childName = sanitize(targetPath, maintainEntryPath ? child.entryName : pth.basename(child.entryName));\r\n\r\n\t\t\t\t\tUtils.writeFileTo(childName, content, overwrite);\r\n\t\t\t\t});\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\r\n\t\t\tvar content = item.getData();\r\n\t\t\tif (!content) throw new Error(Utils.Errors.CANT_EXTRACT_FILE);\r\n\r\n\t\t\tif (fs.existsSync(target) && !overwrite) {\r\n\t\t\t\tthrow new Error(Utils.Errors.CANT_OVERRIDE);\r\n\t\t\t}\r\n\t\t\tUtils.writeFileTo(target, content, overwrite);\r\n\r\n\t\t\treturn true;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Test the archive\r\n\t\t *\r\n\t\t */\r\n\t\ttest: function () {\r\n\t\t\tif (!_zip) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\r\n\t\t\tfor (var entry in _zip.entries) {\r\n\t\t\t\ttry {\r\n\t\t\t\t\tif (entry.isDirectory) {\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvar content = _zip.entries[entry].getData();\r\n\t\t\t\t\tif (!content) {\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t}\r\n\t\t\t\t} catch (err) {\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn true;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Extracts the entire archive to the given location\r\n\t\t *\r\n\t\t * @param targetPath Target location\r\n\t\t * @param overwrite If the file already exists at the target path, the file will be overwriten if this is true.\r\n\t\t *                  Default is FALSE\r\n\t\t */\r\n\t\textractAllTo: function (/**String*/targetPath, /**Boolean*/overwrite) {\r\n\t\t\toverwrite = overwrite || false;\r\n\t\t\tif (!_zip) {\r\n\t\t\t\tthrow new Error(Utils.Errors.NO_ZIP);\r\n\t\t\t}\r\n\t\t\t_zip.entries.forEach(function (entry) {\r\n\t\t\t\tvar entryName = sanitize(targetPath, entry.entryName.toString());\r\n\t\t\t\tif (entry.isDirectory) {\r\n\t\t\t\t\tUtils.makeDir(entryName);\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\tvar content = entry.getData();\r\n\t\t\t\tif (!content) {\r\n\t\t\t\t\tthrow new Error(Utils.Errors.CANT_EXTRACT_FILE);\r\n\t\t\t\t}\r\n\t\t\t\tUtils.writeFileTo(entryName, content, overwrite);\r\n\t\t\t\ttry {\r\n\t\t\t\t\tfs.utimesSync(entryName, entry.header.time, entry.header.time)\r\n\t\t\t\t} catch (err) {\r\n\t\t\t\t\tthrow new Error(Utils.Errors.CANT_EXTRACT_FILE);\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Asynchronous extractAllTo\r\n\t\t *\r\n\t\t * @param targetPath Target location\r\n\t\t * @param overwrite If the file already exists at the target path, the file will be overwriten if this is true.\r\n\t\t *                  Default is FALSE\r\n\t\t * @param callback\r\n\t\t */\r\n\t\textractAllToAsync: function (/**String*/targetPath, /**Boolean*/overwrite, /**Function*/callback) {\r\n\t\t\tif (!callback) {\r\n\t\t\t\tcallback = function() {}\r\n\t\t\t}\r\n\t\t\toverwrite = overwrite || false;\r\n\t\t\tif (!_zip) {\r\n\t\t\t\tcallback(new Error(Utils.Errors.NO_ZIP));\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tvar entries = _zip.entries;\r\n\t\t\tvar i = entries.length;\r\n\t\t\tentries.forEach(function (entry) {\r\n\t\t\t\tif (i <= 0) return; // Had an error already\r\n\r\n\t\t\t\tvar entryName = pth.normalize(entry.entryName.toString());\r\n\r\n\t\t\t\tif (entry.isDirectory) {\r\n\t\t\t\t\tUtils.makeDir(sanitize(targetPath, entryName));\r\n\t\t\t\t\tif (--i === 0)\r\n\t\t\t\t\t\tcallback(undefined);\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\tentry.getDataAsync(function (content, err) {\r\n\t\t\t\t\tif (i <= 0) return;\r\n\t\t\t\t\tif (err) {\r\n\t\t\t\t\t\tcallback(new Error(err));\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (!content) {\r\n\t\t\t\t\t\ti = 0;\r\n\t\t\t\t\t\tcallback(new Error(Utils.Errors.CANT_EXTRACT_FILE));\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tUtils.writeFileToAsync(sanitize(targetPath, entryName), content, overwrite, function (succ) {\r\n\t\t\t\t\t\ttry {\r\n\t\t\t\t\t\t\tfs.utimesSync(pth.resolve(targetPath, entryName), entry.header.time, entry.header.time);\r\n\t\t\t\t\t\t} catch (err) {\r\n\t\t\t\t\t\t\tcallback(new Error('Unable to set utimes'));\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (i <= 0) return;\r\n\t\t\t\t\t\tif (!succ) {\r\n\t\t\t\t\t\t\ti = 0;\r\n\t\t\t\t\t\t\tcallback(new Error('Unable to write'));\r\n\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (--i === 0)\r\n\t\t\t\t\t\t\tcallback(undefined);\r\n\t\t\t\t\t});\r\n\t\t\t\t});\r\n\t\t\t})\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Writes the newly created zip file to disk at the specified location or if a zip was opened and no ``targetFileName`` is provided, it will overwrite the opened zip\r\n\t\t *\r\n\t\t * @param targetFileName\r\n\t\t * @param callback\r\n\t\t */\r\n\t\twriteZip: function (/**String*/targetFileName, /**Function*/callback) {\r\n\t\t\tif (arguments.length === 1) {\r\n\t\t\t\tif (typeof targetFileName === \"function\") {\r\n\t\t\t\t\tcallback = targetFileName;\r\n\t\t\t\t\ttargetFileName = \"\";\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (!targetFileName && _filename) {\r\n\t\t\t\ttargetFileName = _filename;\r\n\t\t\t}\r\n\t\t\tif (!targetFileName) return;\r\n\r\n\t\t\tvar zipData = _zip.compressToBuffer();\r\n\t\t\tif (zipData) {\r\n\t\t\t\tvar ok = Utils.writeFileTo(targetFileName, zipData, true);\r\n\t\t\t\tif (typeof callback === 'function') callback(!ok ? new Error(\"failed\") : null, \"\");\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Returns the content of the entire zip file as a Buffer object\r\n\t\t *\r\n\t\t * @return Buffer\r\n\t\t */\r\n\t\ttoBuffer: function (/**Function=*/onSuccess, /**Function=*/onFail, /**Function=*/onItemStart, /**Function=*/onItemEnd) {\r\n\t\t\tthis.valueOf = 2;\r\n\t\t\tif (typeof onSuccess === \"function\") {\r\n\t\t\t\t_zip.toAsyncBuffer(onSuccess, onFail, onItemStart, onItemEnd);\r\n\t\t\t\treturn null;\r\n\t\t\t}\r\n\t\t\treturn _zip.compressToBuffer()\r\n\t\t}\r\n\t}\r\n};\r\n"]},"metadata":{},"sourceType":"script"}