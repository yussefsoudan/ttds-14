{"ast":null,"code":"var ZipEntry = require(\"./zipEntry\"),\n    Headers = require(\"./headers\"),\n    Utils = require(\"./util\");\n\nmodule.exports = function (\n/*String|Buffer*/\ninput,\n/*Number*/\ninputType) {\n  var entryList = [],\n      entryTable = {},\n      _comment = Buffer.alloc(0),\n      filename = \"\",\n      fs = Utils.FileSystem.require(),\n      inBuffer = null,\n      mainHeader = new Headers.MainHeader(),\n      loadedEntries = false;\n\n  if (inputType === Utils.Constants.FILE) {\n    // is a filename\n    filename = input;\n    inBuffer = fs.readFileSync(filename);\n    readMainHeader();\n  } else if (inputType === Utils.Constants.BUFFER) {\n    // is a memory buffer\n    inBuffer = input;\n    readMainHeader();\n  } else {\n    // none. is a new file\n    loadedEntries = true;\n  }\n\n  function iterateEntries(callback) {\n    const totalEntries = mainHeader.diskEntries; // total number of entries\n\n    let index = mainHeader.offset; // offset of first CEN header\n\n    for (let i = 0; i < totalEntries; i++) {\n      let tmp = index;\n      const entry = new ZipEntry(inBuffer);\n      entry.header = inBuffer.slice(tmp, tmp += Utils.Constants.CENHDR);\n      entry.entryName = inBuffer.slice(tmp, tmp += entry.header.fileNameLength);\n      index += entry.header.entryHeaderSize;\n      callback(entry);\n    }\n  }\n\n  function readEntries() {\n    loadedEntries = true;\n    entryTable = {};\n    entryList = new Array(mainHeader.diskEntries); // total number of entries\n\n    var index = mainHeader.offset; // offset of first CEN header\n\n    for (var i = 0; i < entryList.length; i++) {\n      var tmp = index,\n          entry = new ZipEntry(inBuffer);\n      entry.header = inBuffer.slice(tmp, tmp += Utils.Constants.CENHDR);\n      entry.entryName = inBuffer.slice(tmp, tmp += entry.header.fileNameLength);\n\n      if (entry.header.extraLength) {\n        entry.extra = inBuffer.slice(tmp, tmp += entry.header.extraLength);\n      }\n\n      if (entry.header.commentLength) entry.comment = inBuffer.slice(tmp, tmp + entry.header.commentLength);\n      index += entry.header.entryHeaderSize;\n      entryList[i] = entry;\n      entryTable[entry.entryName] = entry;\n    }\n  }\n\n  function readMainHeader() {\n    var i = inBuffer.length - Utils.Constants.ENDHDR,\n        // END header size\n    max = Math.max(0, i - 0xFFFF),\n        // 0xFFFF is the max zip file comment length\n    n = max,\n        endStart = inBuffer.length,\n        endOffset = -1,\n        // Start offset of the END header\n    commentEnd = 0;\n\n    for (i; i >= n; i--) {\n      if (inBuffer[i] !== 0x50) continue; // quick check that the byte is 'P'\n\n      if (inBuffer.readUInt32LE(i) === Utils.Constants.ENDSIG) {\n        // \"PK\\005\\006\"\n        endOffset = i;\n        commentEnd = i;\n        endStart = i + Utils.Constants.ENDHDR; // We already found a regular signature, let's look just a bit further to check if there's any zip64 signature\n\n        n = i - Utils.Constants.END64HDR;\n        continue;\n      }\n\n      if (inBuffer.readUInt32LE(i) === Utils.Constants.END64SIG) {\n        // Found a zip64 signature, let's continue reading the whole zip64 record\n        n = max;\n        continue;\n      }\n\n      if (inBuffer.readUInt32LE(i) == Utils.Constants.ZIP64SIG) {\n        // Found the zip64 record, let's determine it's size\n        endOffset = i;\n        endStart = i + Utils.readBigUInt64LE(inBuffer, i + Utils.Constants.ZIP64SIZE) + Utils.Constants.ZIP64LEAD;\n        break;\n      }\n    }\n\n    if (!~endOffset) throw new Error(Utils.Errors.INVALID_FORMAT);\n    mainHeader.loadFromBinary(inBuffer.slice(endOffset, endStart));\n\n    if (mainHeader.commentLength) {\n      _comment = inBuffer.slice(commentEnd + Utils.Constants.ENDHDR);\n    } // readEntries();\n\n  }\n\n  return {\n    /**\r\n     * Returns an array of ZipEntry objects existent in the current opened archive\r\n     * @return Array\r\n     */\n    get entries() {\n      if (!loadedEntries) {\n        readEntries();\n      }\n\n      return entryList;\n    },\n\n    /**\r\n     * Archive comment\r\n     * @return {String}\r\n     */\n    get comment() {\n      return _comment.toString();\n    },\n\n    set comment(val) {\n      mainHeader.commentLength = val.length;\n      _comment = val;\n    },\n\n    getEntryCount: function () {\n      if (!loadedEntries) {\n        return mainHeader.diskEntries;\n      }\n\n      return entryList.length;\n    },\n    forEach: function (callback) {\n      if (!loadedEntries) {\n        iterateEntries(callback);\n        return;\n      }\n\n      entryList.forEach(callback);\n    },\n\n    /**\r\n     * Returns a reference to the entry with the given name or null if entry is inexistent\r\n     *\r\n     * @param entryName\r\n     * @return ZipEntry\r\n     */\n    getEntry: function (\n    /*String*/\n    entryName) {\n      if (!loadedEntries) {\n        readEntries();\n      }\n\n      return entryTable[entryName] || null;\n    },\n\n    /**\r\n     * Adds the given entry to the entry list\r\n     *\r\n     * @param entry\r\n     */\n    setEntry: function (\n    /*ZipEntry*/\n    entry) {\n      if (!loadedEntries) {\n        readEntries();\n      }\n\n      entryList.push(entry);\n      entryTable[entry.entryName] = entry;\n      mainHeader.totalEntries = entryList.length;\n    },\n\n    /**\r\n     * Removes the entry with the given name from the entry list.\r\n     *\r\n     * If the entry is a directory, then all nested files and directories will be removed\r\n     * @param entryName\r\n     */\n    deleteEntry: function (\n    /*String*/\n    entryName) {\n      if (!loadedEntries) {\n        readEntries();\n      }\n\n      var entry = entryTable[entryName];\n\n      if (entry && entry.isDirectory) {\n        var _self = this;\n\n        this.getEntryChildren(entry).forEach(function (child) {\n          if (child.entryName !== entryName) {\n            _self.deleteEntry(child.entryName);\n          }\n        });\n      }\n\n      entryList.splice(entryList.indexOf(entry), 1);\n      delete entryTable[entryName];\n      mainHeader.totalEntries = entryList.length;\n    },\n\n    /**\r\n     *  Iterates and returns all nested files and directories of the given entry\r\n     *\r\n     * @param entry\r\n     * @return Array\r\n     */\n    getEntryChildren: function (\n    /*ZipEntry*/\n    entry) {\n      if (!loadedEntries) {\n        readEntries();\n      }\n\n      if (entry.isDirectory) {\n        var list = [],\n            name = entry.entryName,\n            len = name.length;\n        entryList.forEach(function (zipEntry) {\n          if (zipEntry.entryName.substr(0, len) === name) {\n            list.push(zipEntry);\n          }\n        });\n        return list;\n      }\n\n      return [];\n    },\n\n    /**\r\n     * Returns the zip file\r\n     *\r\n     * @return Buffer\r\n     */\n    compressToBuffer: function () {\n      if (!loadedEntries) {\n        readEntries();\n      }\n\n      if (entryList.length > 1) {\n        entryList.sort(function (a, b) {\n          var nameA = a.entryName.toLowerCase();\n          var nameB = b.entryName.toLowerCase();\n\n          if (nameA < nameB) {\n            return -1;\n          }\n\n          if (nameA > nameB) {\n            return 1;\n          }\n\n          return 0;\n        });\n      }\n\n      var totalSize = 0,\n          dataBlock = [],\n          entryHeaders = [],\n          dindex = 0;\n      mainHeader.size = 0;\n      mainHeader.offset = 0;\n      entryList.forEach(function (entry) {\n        // compress data and set local and entry header accordingly. Reason why is called first\n        var compressedData = entry.getCompressedData(); // data header\n\n        entry.header.offset = dindex;\n        var dataHeader = entry.header.dataHeaderToBinary();\n        var entryNameLen = entry.rawEntryName.length;\n        var extra = entry.extra.toString();\n        var postHeader = Buffer.alloc(entryNameLen + extra.length);\n        entry.rawEntryName.copy(postHeader, 0);\n        postHeader.fill(extra, entryNameLen);\n        var dataLength = dataHeader.length + postHeader.length + compressedData.length;\n        dindex += dataLength;\n        dataBlock.push(dataHeader);\n        dataBlock.push(postHeader);\n        dataBlock.push(compressedData);\n        var entryHeader = entry.packHeader();\n        entryHeaders.push(entryHeader);\n        mainHeader.size += entryHeader.length;\n        totalSize += dataLength + entryHeader.length;\n      });\n      totalSize += mainHeader.mainHeaderSize; // also includes zip file comment length\n      // point to end of data and beginning of central directory first record\n\n      mainHeader.offset = dindex;\n      dindex = 0;\n      var outBuffer = Buffer.alloc(totalSize);\n      dataBlock.forEach(function (content) {\n        content.copy(outBuffer, dindex); // write data blocks\n\n        dindex += content.length;\n      });\n      entryHeaders.forEach(function (content) {\n        content.copy(outBuffer, dindex); // write central directory entries\n\n        dindex += content.length;\n      });\n      var mh = mainHeader.toBinary();\n\n      if (_comment) {\n        Buffer.from(_comment).copy(mh, Utils.Constants.ENDHDR); // add zip file comment\n      }\n\n      mh.copy(outBuffer, dindex); // write main header\n\n      return outBuffer;\n    },\n    toAsyncBuffer: function (\n    /*Function*/\n    onSuccess,\n    /*Function*/\n    onFail,\n    /*Function*/\n    onItemStart,\n    /*Function*/\n    onItemEnd) {\n      if (!loadedEntries) {\n        readEntries();\n      }\n\n      if (entryList.length > 1) {\n        entryList.sort(function (a, b) {\n          var nameA = a.entryName.toLowerCase();\n          var nameB = b.entryName.toLowerCase();\n\n          if (nameA > nameB) {\n            return -1;\n          }\n\n          if (nameA < nameB) {\n            return 1;\n          }\n\n          return 0;\n        });\n      }\n\n      var totalSize = 0,\n          dataBlock = [],\n          entryHeaders = [],\n          dindex = 0;\n      mainHeader.size = 0;\n      mainHeader.offset = 0;\n\n      var compress = function (entryList) {\n        var self = arguments.callee;\n\n        if (entryList.length) {\n          var entry = entryList.pop();\n          var name = entry.entryName + entry.extra.toString();\n          if (onItemStart) onItemStart(name);\n          entry.getCompressedDataAsync(function (compressedData) {\n            if (onItemEnd) onItemEnd(name);\n            entry.header.offset = dindex; // data header\n\n            var dataHeader = entry.header.dataHeaderToBinary();\n            var postHeader;\n\n            try {\n              postHeader = Buffer.alloc(name.length, name); // using alloc will work on node  5.x+\n            } catch (e) {\n              postHeader = new Buffer(name); // use deprecated method if alloc fails...\n            }\n\n            var dataLength = dataHeader.length + postHeader.length + compressedData.length;\n            dindex += dataLength;\n            dataBlock.push(dataHeader);\n            dataBlock.push(postHeader);\n            dataBlock.push(compressedData);\n            var entryHeader = entry.packHeader();\n            entryHeaders.push(entryHeader);\n            mainHeader.size += entryHeader.length;\n            totalSize += dataLength + entryHeader.length;\n\n            if (entryList.length) {\n              self(entryList);\n            } else {\n              totalSize += mainHeader.mainHeaderSize; // also includes zip file comment length\n              // point to end of data and beginning of central directory first record\n\n              mainHeader.offset = dindex;\n              dindex = 0;\n              var outBuffer = Buffer.alloc(totalSize);\n              dataBlock.forEach(function (content) {\n                content.copy(outBuffer, dindex); // write data blocks\n\n                dindex += content.length;\n              });\n              entryHeaders.forEach(function (content) {\n                content.copy(outBuffer, dindex); // write central directory entries\n\n                dindex += content.length;\n              });\n              var mh = mainHeader.toBinary();\n\n              if (_comment) {\n                _comment.copy(mh, Utils.Constants.ENDHDR); // add zip file comment\n\n              }\n\n              mh.copy(outBuffer, dindex); // write main header\n\n              onSuccess(outBuffer);\n            }\n          });\n        }\n      };\n\n      compress(entryList);\n    }\n  };\n};","map":{"version":3,"sources":["/Users/yussefsoudan/Studies/Uni/year-4-cs/TTDS/CW3/ttds-14/website/book-search-client/node_modules/adm-zip/zipFile.js"],"names":["ZipEntry","require","Headers","Utils","module","exports","input","inputType","entryList","entryTable","_comment","Buffer","alloc","filename","fs","FileSystem","inBuffer","mainHeader","MainHeader","loadedEntries","Constants","FILE","readFileSync","readMainHeader","BUFFER","iterateEntries","callback","totalEntries","diskEntries","index","offset","i","tmp","entry","header","slice","CENHDR","entryName","fileNameLength","entryHeaderSize","readEntries","Array","length","extraLength","extra","commentLength","comment","ENDHDR","max","Math","n","endStart","endOffset","commentEnd","readUInt32LE","ENDSIG","END64HDR","END64SIG","ZIP64SIG","readBigUInt64LE","ZIP64SIZE","ZIP64LEAD","Error","Errors","INVALID_FORMAT","loadFromBinary","entries","toString","val","getEntryCount","forEach","getEntry","setEntry","push","deleteEntry","isDirectory","_self","getEntryChildren","child","splice","indexOf","list","name","len","zipEntry","substr","compressToBuffer","sort","a","b","nameA","toLowerCase","nameB","totalSize","dataBlock","entryHeaders","dindex","size","compressedData","getCompressedData","dataHeader","dataHeaderToBinary","entryNameLen","rawEntryName","postHeader","copy","fill","dataLength","entryHeader","packHeader","mainHeaderSize","outBuffer","content","mh","toBinary","from","toAsyncBuffer","onSuccess","onFail","onItemStart","onItemEnd","compress","self","arguments","callee","pop","getCompressedDataAsync","e"],"mappings":"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","sourcesContent":["var ZipEntry = require(\"./zipEntry\"),\r\n\tHeaders = require(\"./headers\"),\r\n\tUtils = require(\"./util\");\r\n\r\nmodule.exports = function (/*String|Buffer*/input, /*Number*/inputType) {\r\n\tvar entryList = [],\r\n\t\tentryTable = {},\r\n\t\t_comment = Buffer.alloc(0),\r\n\t\tfilename = \"\",\r\n\t\tfs = Utils.FileSystem.require(),\r\n\t\tinBuffer = null,\r\n\t\tmainHeader = new Headers.MainHeader(),\r\n\t\tloadedEntries = false;\r\n\r\n\tif (inputType === Utils.Constants.FILE) {\r\n\t\t// is a filename\r\n\t\tfilename = input;\r\n\t\tinBuffer = fs.readFileSync(filename);\r\n\t\treadMainHeader();\r\n\t} else if (inputType === Utils.Constants.BUFFER) {\r\n\t\t// is a memory buffer\r\n\t\tinBuffer = input;\r\n\t\treadMainHeader();\r\n\t} else {\r\n\t\t// none. is a new file\r\n\t\tloadedEntries = true;\r\n\t}\r\n\r\n\tfunction iterateEntries(callback) {\r\n\t\tconst totalEntries = mainHeader.diskEntries; // total number of entries\r\n\t\tlet index = mainHeader.offset; // offset of first CEN header\r\n\r\n\t\tfor (let i = 0; i < totalEntries; i++) {\r\n\t\t\tlet tmp = index;\r\n\t\t\tconst entry = new ZipEntry(inBuffer);\r\n\r\n\t\t\tentry.header = inBuffer.slice(tmp, tmp += Utils.Constants.CENHDR);\r\n\t\t\tentry.entryName = inBuffer.slice(tmp, tmp += entry.header.fileNameLength);\r\n\r\n\t\t\tindex += entry.header.entryHeaderSize;\r\n\r\n\t\t\tcallback(entry);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction readEntries() {\r\n\t\tloadedEntries = true;\r\n\t\tentryTable = {};\r\n\t\tentryList = new Array(mainHeader.diskEntries);  // total number of entries\r\n\t\tvar index = mainHeader.offset;  // offset of first CEN header\r\n\t\tfor (var i = 0; i < entryList.length; i++) {\r\n\r\n\t\t\tvar tmp = index,\r\n\t\t\t\tentry = new ZipEntry(inBuffer);\r\n\t\t\tentry.header = inBuffer.slice(tmp, tmp += Utils.Constants.CENHDR);\r\n\r\n\t\t\tentry.entryName = inBuffer.slice(tmp, tmp += entry.header.fileNameLength);\r\n\r\n\t\t\tif (entry.header.extraLength) {\r\n\t\t\t\tentry.extra = inBuffer.slice(tmp, tmp += entry.header.extraLength);\r\n\t\t\t}\r\n\r\n\t\t\tif (entry.header.commentLength)\r\n\t\t\t\tentry.comment = inBuffer.slice(tmp, tmp + entry.header.commentLength);\r\n\r\n\t\t\tindex += entry.header.entryHeaderSize;\r\n\r\n\t\t\tentryList[i] = entry;\r\n\t\t\tentryTable[entry.entryName] = entry;\r\n\t\t}\r\n\t}\r\n\r\n\tfunction readMainHeader() {\r\n\t\tvar i = inBuffer.length - Utils.Constants.ENDHDR, // END header size\r\n\t\t\tmax = Math.max(0, i - 0xFFFF), // 0xFFFF is the max zip file comment length\r\n\t\t\tn = max,\r\n\t\t\tendStart = inBuffer.length,\r\n\t\t\tendOffset = -1, // Start offset of the END header\r\n\t\t\tcommentEnd = 0;\r\n\r\n\t\tfor (i; i >= n; i--) {\r\n\t\t\tif (inBuffer[i] !== 0x50) continue; // quick check that the byte is 'P'\r\n\t\t\tif (inBuffer.readUInt32LE(i) === Utils.Constants.ENDSIG) { // \"PK\\005\\006\"\r\n\t\t\t\tendOffset = i;\r\n\t\t\t\tcommentEnd = i;\r\n\t\t\t\tendStart = i + Utils.Constants.ENDHDR;\r\n\t\t\t\t// We already found a regular signature, let's look just a bit further to check if there's any zip64 signature\r\n\t\t\t\tn = i - Utils.Constants.END64HDR;\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\tif (inBuffer.readUInt32LE(i) === Utils.Constants.END64SIG) {\r\n\t\t\t\t// Found a zip64 signature, let's continue reading the whole zip64 record\r\n\t\t\t\tn = max;\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\tif (inBuffer.readUInt32LE(i) == Utils.Constants.ZIP64SIG) {\r\n\t\t\t\t// Found the zip64 record, let's determine it's size\r\n\t\t\t\tendOffset = i;\r\n\t\t\t\tendStart = i + Utils.readBigUInt64LE(inBuffer, i + Utils.Constants.ZIP64SIZE) + Utils.Constants.ZIP64LEAD;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (!~endOffset)\r\n\t\t\tthrow new Error(Utils.Errors.INVALID_FORMAT);\r\n\r\n\t\tmainHeader.loadFromBinary(inBuffer.slice(endOffset, endStart));\r\n\t\tif (mainHeader.commentLength) {\r\n\t\t\t_comment = inBuffer.slice(commentEnd + Utils.Constants.ENDHDR);\r\n\t\t}\r\n\t\t// readEntries();\r\n\t}\r\n\r\n\treturn {\r\n\t\t/**\r\n\t\t * Returns an array of ZipEntry objects existent in the current opened archive\r\n\t\t * @return Array\r\n\t\t */\r\n\t\tget entries() {\r\n\t\t\tif (!loadedEntries) {\r\n\t\t\t\treadEntries();\r\n\t\t\t}\r\n\t\t\treturn entryList;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Archive comment\r\n\t\t * @return {String}\r\n\t\t */\r\n\t\tget comment() {\r\n\t\t\treturn _comment.toString();\r\n\t\t},\r\n\t\tset comment(val) {\r\n\t\t\tmainHeader.commentLength = val.length;\r\n\t\t\t_comment = val;\r\n\t\t},\r\n\r\n\t\tgetEntryCount: function() {\r\n\t\t\tif (!loadedEntries) {\r\n\t\t\t\treturn mainHeader.diskEntries;\r\n\t\t\t}\r\n\r\n\t\t\treturn entryList.length;\r\n\t\t},\r\n\r\n\t\tforEach: function(callback) {\r\n\t\t\tif (!loadedEntries) {\r\n\t\t\t\titerateEntries(callback);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tentryList.forEach(callback);\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Returns a reference to the entry with the given name or null if entry is inexistent\r\n\t\t *\r\n\t\t * @param entryName\r\n\t\t * @return ZipEntry\r\n\t\t */\r\n\t\tgetEntry: function (/*String*/entryName) {\r\n\t\t\tif (!loadedEntries) {\r\n\t\t\t\treadEntries();\r\n\t\t\t}\r\n\t\t\treturn entryTable[entryName] || null;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Adds the given entry to the entry list\r\n\t\t *\r\n\t\t * @param entry\r\n\t\t */\r\n\t\tsetEntry: function (/*ZipEntry*/entry) {\r\n\t\t\tif (!loadedEntries) {\r\n\t\t\t\treadEntries();\r\n\t\t\t}\r\n\t\t\tentryList.push(entry);\r\n\t\t\tentryTable[entry.entryName] = entry;\r\n\t\t\tmainHeader.totalEntries = entryList.length;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Removes the entry with the given name from the entry list.\r\n\t\t *\r\n\t\t * If the entry is a directory, then all nested files and directories will be removed\r\n\t\t * @param entryName\r\n\t\t */\r\n\t\tdeleteEntry: function (/*String*/entryName) {\r\n\t\t\tif (!loadedEntries) {\r\n\t\t\t\treadEntries();\r\n\t\t\t}\r\n\t\t\tvar entry = entryTable[entryName];\r\n\t\t\tif (entry && entry.isDirectory) {\r\n\t\t\t\tvar _self = this;\r\n\t\t\t\tthis.getEntryChildren(entry).forEach(function (child) {\r\n\t\t\t\t\tif (child.entryName !== entryName) {\r\n\t\t\t\t\t\t_self.deleteEntry(child.entryName)\r\n\t\t\t\t\t}\r\n\t\t\t\t})\r\n\t\t\t}\r\n\t\t\tentryList.splice(entryList.indexOf(entry), 1);\r\n\t\t\tdelete(entryTable[entryName]);\r\n\t\t\tmainHeader.totalEntries = entryList.length;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t *  Iterates and returns all nested files and directories of the given entry\r\n\t\t *\r\n\t\t * @param entry\r\n\t\t * @return Array\r\n\t\t */\r\n\t\tgetEntryChildren: function (/*ZipEntry*/entry) {\r\n\t\t\tif (!loadedEntries) {\r\n\t\t\t\treadEntries();\r\n\t\t\t}\r\n\t\t\tif (entry.isDirectory) {\r\n\t\t\t\tvar list = [],\r\n\t\t\t\t\tname = entry.entryName,\r\n\t\t\t\t\tlen = name.length;\r\n\r\n\t\t\t\tentryList.forEach(function (zipEntry) {\r\n\t\t\t\t\tif (zipEntry.entryName.substr(0, len) === name) {\r\n\t\t\t\t\t\tlist.push(zipEntry);\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t\treturn list;\r\n\t\t\t}\r\n\t\t\treturn []\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Returns the zip file\r\n\t\t *\r\n\t\t * @return Buffer\r\n\t\t */\r\n\t\tcompressToBuffer: function () {\r\n\t\t\tif (!loadedEntries) {\r\n\t\t\t\treadEntries();\r\n\t\t\t}\r\n\t\t\tif (entryList.length > 1) {\r\n\t\t\t\tentryList.sort(function (a, b) {\r\n\t\t\t\t\tvar nameA = a.entryName.toLowerCase();\r\n\t\t\t\t\tvar nameB = b.entryName.toLowerCase();\r\n\t\t\t\t\tif (nameA < nameB) {\r\n\t\t\t\t\t\treturn -1\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (nameA > nameB) {\r\n\t\t\t\t\t\treturn 1\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn 0;\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\tvar totalSize = 0,\r\n\t\t\t\tdataBlock = [],\r\n\t\t\t\tentryHeaders = [],\r\n\t\t\t\tdindex = 0;\r\n\r\n\t\t\tmainHeader.size = 0;\r\n\t\t\tmainHeader.offset = 0;\r\n\r\n\t\t\tentryList.forEach(function (entry) {\r\n\t\t\t\t// compress data and set local and entry header accordingly. Reason why is called first\r\n\t\t\t\tvar compressedData = entry.getCompressedData();\r\n\t\t\t\t// data header\r\n\t\t\t\tentry.header.offset = dindex;\r\n\t\t\t\tvar dataHeader = entry.header.dataHeaderToBinary();\r\n\t\t\t\tvar entryNameLen = entry.rawEntryName.length;\r\n\t\t\t\tvar extra = entry.extra.toString();\r\n\t\t\t\tvar postHeader = Buffer.alloc(entryNameLen + extra.length);\r\n\t\t\t\tentry.rawEntryName.copy(postHeader, 0);\r\n\t\t\t\tpostHeader.fill(extra, entryNameLen);\r\n\r\n\t\t\t\tvar dataLength = dataHeader.length + postHeader.length + compressedData.length;\r\n\r\n\t\t\t\tdindex += dataLength;\r\n\r\n\t\t\t\tdataBlock.push(dataHeader);\r\n\t\t\t\tdataBlock.push(postHeader);\r\n\t\t\t\tdataBlock.push(compressedData);\r\n\r\n\t\t\t\tvar entryHeader = entry.packHeader();\r\n\t\t\t\tentryHeaders.push(entryHeader);\r\n\t\t\t\tmainHeader.size += entryHeader.length;\r\n\t\t\t\ttotalSize += (dataLength + entryHeader.length);\r\n\t\t\t});\r\n\r\n\t\t\ttotalSize += mainHeader.mainHeaderSize; // also includes zip file comment length\r\n\t\t\t// point to end of data and beginning of central directory first record\r\n\t\t\tmainHeader.offset = dindex;\r\n\r\n\t\t\tdindex = 0;\r\n\t\t\tvar outBuffer = Buffer.alloc(totalSize);\r\n\t\t\tdataBlock.forEach(function (content) {\r\n\t\t\t\tcontent.copy(outBuffer, dindex); // write data blocks\r\n\t\t\t\tdindex += content.length;\r\n\t\t\t});\r\n\t\t\tentryHeaders.forEach(function (content) {\r\n\t\t\t\tcontent.copy(outBuffer, dindex); // write central directory entries\r\n\t\t\t\tdindex += content.length;\r\n\t\t\t});\r\n\r\n\t\t\tvar mh = mainHeader.toBinary();\r\n\t\t\tif (_comment) {\r\n\t\t\t\tBuffer.from(_comment).copy(mh, Utils.Constants.ENDHDR); // add zip file comment\r\n\t\t\t}\r\n\r\n\t\t\tmh.copy(outBuffer, dindex); // write main header\r\n\r\n\t\t\treturn outBuffer\r\n\t\t},\r\n\r\n\t\ttoAsyncBuffer: function (/*Function*/onSuccess, /*Function*/onFail, /*Function*/onItemStart, /*Function*/onItemEnd) {\r\n\t\t\tif (!loadedEntries) {\r\n\t\t\t\treadEntries();\r\n\t\t\t}\r\n\t\t\tif (entryList.length > 1) {\r\n\t\t\t\tentryList.sort(function (a, b) {\r\n\t\t\t\t\tvar nameA = a.entryName.toLowerCase();\r\n\t\t\t\t\tvar nameB = b.entryName.toLowerCase();\r\n\t\t\t\t\tif (nameA > nameB) {\r\n\t\t\t\t\t\treturn -1\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (nameA < nameB) {\r\n\t\t\t\t\t\treturn 1\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn 0;\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\tvar totalSize = 0,\r\n\t\t\t\tdataBlock = [],\r\n\t\t\t\tentryHeaders = [],\r\n\t\t\t\tdindex = 0;\r\n\r\n\t\t\tmainHeader.size = 0;\r\n\t\t\tmainHeader.offset = 0;\r\n\r\n\t\t\tvar compress = function (entryList) {\r\n\t\t\t\tvar self = arguments.callee;\r\n\t\t\t\tif (entryList.length) {\r\n\t\t\t\t\tvar entry = entryList.pop();\r\n\t\t\t\t\tvar name = entry.entryName + entry.extra.toString();\r\n\t\t\t\t\tif (onItemStart) onItemStart(name);\r\n\t\t\t\t\tentry.getCompressedDataAsync(function (compressedData) {\r\n\t\t\t\t\t\tif (onItemEnd) onItemEnd(name);\r\n\r\n\t\t\t\t\t\tentry.header.offset = dindex;\r\n\t\t\t\t\t\t// data header\r\n\t\t\t\t\t\tvar dataHeader = entry.header.dataHeaderToBinary();\r\n\t\t\t\t\t\tvar postHeader;\r\n\t\t\t\t\t\ttry {\r\n\t\t\t\t\t\t\tpostHeader = Buffer.alloc(name.length, name);  // using alloc will work on node  5.x+\r\n\t\t\t\t\t\t} catch(e){\r\n\t\t\t\t\t\t\tpostHeader = new Buffer(name); // use deprecated method if alloc fails...\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tvar dataLength = dataHeader.length + postHeader.length + compressedData.length;\r\n\r\n\t\t\t\t\t\tdindex += dataLength;\r\n\r\n\t\t\t\t\t\tdataBlock.push(dataHeader);\r\n\t\t\t\t\t\tdataBlock.push(postHeader);\r\n\t\t\t\t\t\tdataBlock.push(compressedData);\r\n\r\n\t\t\t\t\t\tvar entryHeader = entry.packHeader();\r\n\t\t\t\t\t\tentryHeaders.push(entryHeader);\r\n\t\t\t\t\t\tmainHeader.size += entryHeader.length;\r\n\t\t\t\t\t\ttotalSize += (dataLength + entryHeader.length);\r\n\r\n\t\t\t\t\t\tif (entryList.length) {\r\n\t\t\t\t\t\t\tself(entryList);\r\n\t\t\t\t\t\t} else {\r\n\r\n\r\n\t\t\t\t\t\t\ttotalSize += mainHeader.mainHeaderSize; // also includes zip file comment length\r\n\t\t\t\t\t\t\t// point to end of data and beginning of central directory first record\r\n\t\t\t\t\t\t\tmainHeader.offset = dindex;\r\n\r\n\t\t\t\t\t\t\tdindex = 0;\r\n\t\t\t\t\t\t\tvar outBuffer = Buffer.alloc(totalSize);\r\n\t\t\t\t\t\t\tdataBlock.forEach(function (content) {\r\n\t\t\t\t\t\t\t\tcontent.copy(outBuffer, dindex); // write data blocks\r\n\t\t\t\t\t\t\t\tdindex += content.length;\r\n\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t\tentryHeaders.forEach(function (content) {\r\n\t\t\t\t\t\t\t\tcontent.copy(outBuffer, dindex); // write central directory entries\r\n\t\t\t\t\t\t\t\tdindex += content.length;\r\n\t\t\t\t\t\t\t});\r\n\r\n\t\t\t\t\t\t\tvar mh = mainHeader.toBinary();\r\n\t\t\t\t\t\t\tif (_comment) {\r\n\t\t\t\t\t\t\t\t_comment.copy(mh, Utils.Constants.ENDHDR); // add zip file comment\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tmh.copy(outBuffer, dindex); // write main header\r\n\r\n\t\t\t\t\t\t\tonSuccess(outBuffer);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t};\r\n\r\n\t\t\tcompress(entryList);\r\n\t\t}\r\n\t}\r\n};\r\n"]},"metadata":{},"sourceType":"script"}