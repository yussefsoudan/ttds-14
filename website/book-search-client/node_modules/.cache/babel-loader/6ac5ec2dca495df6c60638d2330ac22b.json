{"ast":null,"code":"/*!\n * Tmp\n *\n * Copyright (c) 2011-2017 KARASZI Istvan <github@spam.raszi.hu>\n *\n * MIT Licensed\n */\n\n/*\n * Module dependencies.\n */\nconst fs = require('fs');\n\nconst os = require('os');\n\nconst path = require('path');\n\nconst crypto = require('crypto');\n\nconst _c = fs.constants && os.constants ? {\n  fs: fs.constants,\n  os: os.constants\n} : process.binding('constants');\n\nconst rimraf = require('rimraf');\n/*\n * The working inner variables.\n */\n\n\nconst // the random characters to choose from\nRANDOM_CHARS = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz',\n      TEMPLATE_PATTERN = /XXXXXX/,\n      DEFAULT_TRIES = 3,\n      CREATE_FLAGS = (_c.O_CREAT || _c.fs.O_CREAT) | (_c.O_EXCL || _c.fs.O_EXCL) | (_c.O_RDWR || _c.fs.O_RDWR),\n      EBADF = _c.EBADF || _c.os.errno.EBADF,\n      ENOENT = _c.ENOENT || _c.os.errno.ENOENT,\n      DIR_MODE = 448\n/* 0o700 */\n,\n      FILE_MODE = 384\n/* 0o600 */\n,\n      EXIT = 'exit',\n      SIGINT = 'SIGINT',\n      // this will hold the objects need to be removed on exit\n_removeObjects = [];\nvar _gracefulCleanup = false;\n/**\n * Random name generator based on crypto.\n * Adapted from http://blog.tompawlak.org/how-to-generate-random-values-nodejs-javascript\n *\n * @param {number} howMany\n * @returns {string} the generated random name\n * @private\n */\n\nfunction _randomChars(howMany) {\n  var value = [],\n      rnd = null; // make sure that we do not fail because we ran out of entropy\n\n  try {\n    rnd = crypto.randomBytes(howMany);\n  } catch (e) {\n    rnd = crypto.pseudoRandomBytes(howMany);\n  }\n\n  for (var i = 0; i < howMany; i++) {\n    value.push(RANDOM_CHARS[rnd[i] % RANDOM_CHARS.length]);\n  }\n\n  return value.join('');\n}\n/**\n * Checks whether the `obj` parameter is defined or not.\n *\n * @param {Object} obj\n * @returns {boolean} true if the object is undefined\n * @private\n */\n\n\nfunction _isUndefined(obj) {\n  return typeof obj === 'undefined';\n}\n/**\n * Parses the function arguments.\n *\n * This function helps to have optional arguments.\n *\n * @param {(Options|Function)} options\n * @param {Function} callback\n * @returns {Array} parsed arguments\n * @private\n */\n\n\nfunction _parseArguments(options, callback) {\n  /* istanbul ignore else */\n  if (typeof options === 'function') {\n    return [{}, options];\n  }\n  /* istanbul ignore else */\n\n\n  if (_isUndefined(options)) {\n    return [{}, callback];\n  }\n\n  return [options, callback];\n}\n/**\n * Generates a new temporary name.\n *\n * @param {Object} opts\n * @returns {string} the new random name according to opts\n * @private\n */\n\n\nfunction _generateTmpName(opts) {\n  const tmpDir = _getTmpDir(); // fail early on missing tmp dir\n\n\n  if (isBlank(opts.dir) && isBlank(tmpDir)) {\n    throw new Error('No tmp dir specified');\n  }\n  /* istanbul ignore else */\n\n\n  if (!isBlank(opts.name)) {\n    return path.join(opts.dir || tmpDir, opts.name);\n  } // mkstemps like template\n  // opts.template has already been guarded in tmpName() below\n\n  /* istanbul ignore else */\n\n\n  if (opts.template) {\n    var template = opts.template; // make sure that we prepend the tmp path if none was given\n\n    /* istanbul ignore else */\n\n    if (path.basename(template) === template) template = path.join(opts.dir || tmpDir, template);\n    return template.replace(TEMPLATE_PATTERN, _randomChars(6));\n  } // prefix and postfix\n\n\n  const name = [isBlank(opts.prefix) ? 'tmp-' : opts.prefix, process.pid, _randomChars(12), opts.postfix ? opts.postfix : ''].join('');\n  return path.join(opts.dir || tmpDir, name);\n}\n/**\n * Gets a temporary file name.\n *\n * @param {(Options|tmpNameCallback)} options options or callback\n * @param {?tmpNameCallback} callback the callback function\n */\n\n\nfunction tmpName(options, callback) {\n  var args = _parseArguments(options, callback),\n      opts = args[0],\n      cb = args[1],\n      tries = !isBlank(opts.name) ? 1 : opts.tries || DEFAULT_TRIES;\n  /* istanbul ignore else */\n\n\n  if (isNaN(tries) || tries < 0) return cb(new Error('Invalid tries'));\n  /* istanbul ignore else */\n\n  if (opts.template && !opts.template.match(TEMPLATE_PATTERN)) return cb(new Error('Invalid template provided'));\n\n  (function _getUniqueName() {\n    try {\n      const name = _generateTmpName(opts); // check whether the path exists then retry if needed\n\n\n      fs.stat(name, function (err) {\n        /* istanbul ignore else */\n        if (!err) {\n          /* istanbul ignore else */\n          if (tries-- > 0) return _getUniqueName();\n          return cb(new Error('Could not get a unique tmp filename, max tries reached ' + name));\n        }\n\n        cb(null, name);\n      });\n    } catch (err) {\n      cb(err);\n    }\n  })();\n}\n/**\n * Synchronous version of tmpName.\n *\n * @param {Object} options\n * @returns {string} the generated random name\n * @throws {Error} if the options are invalid or could not generate a filename\n */\n\n\nfunction tmpNameSync(options) {\n  var args = _parseArguments(options),\n      opts = args[0],\n      tries = !isBlank(opts.name) ? 1 : opts.tries || DEFAULT_TRIES;\n  /* istanbul ignore else */\n\n\n  if (isNaN(tries) || tries < 0) throw new Error('Invalid tries');\n  /* istanbul ignore else */\n\n  if (opts.template && !opts.template.match(TEMPLATE_PATTERN)) throw new Error('Invalid template provided');\n\n  do {\n    const name = _generateTmpName(opts);\n\n    try {\n      fs.statSync(name);\n    } catch (e) {\n      return name;\n    }\n  } while (tries-- > 0);\n\n  throw new Error('Could not get a unique tmp filename, max tries reached');\n}\n/**\n * Creates and opens a temporary file.\n *\n * @param {(Options|fileCallback)} options the config options or the callback function\n * @param {?fileCallback} callback\n */\n\n\nfunction file(options, callback) {\n  var args = _parseArguments(options, callback),\n      opts = args[0],\n      cb = args[1]; // gets a temporary filename\n\n\n  tmpName(opts, function _tmpNameCreated(err, name) {\n    /* istanbul ignore else */\n    if (err) return cb(err); // create and open the file\n\n    fs.open(name, CREATE_FLAGS, opts.mode || FILE_MODE, function _fileCreated(err, fd) {\n      /* istanbul ignore else */\n      if (err) return cb(err);\n\n      if (opts.discardDescriptor) {\n        return fs.close(fd, function _discardCallback(err) {\n          /* istanbul ignore else */\n          if (err) {\n            // Low probability, and the file exists, so this could be\n            // ignored.  If it isn't we certainly need to unlink the\n            // file, and if that fails too its error is more\n            // important.\n            try {\n              fs.unlinkSync(name);\n            } catch (e) {\n              if (!isENOENT(e)) {\n                err = e;\n              }\n            }\n\n            return cb(err);\n          }\n\n          cb(null, name, undefined, _prepareTmpFileRemoveCallback(name, -1, opts));\n        });\n      }\n      /* istanbul ignore else */\n\n\n      if (opts.detachDescriptor) {\n        return cb(null, name, fd, _prepareTmpFileRemoveCallback(name, -1, opts));\n      }\n\n      cb(null, name, fd, _prepareTmpFileRemoveCallback(name, fd, opts));\n    });\n  });\n}\n/**\n * Synchronous version of file.\n *\n * @param {Options} options\n * @returns {FileSyncObject} object consists of name, fd and removeCallback\n * @throws {Error} if cannot create a file\n */\n\n\nfunction fileSync(options) {\n  var args = _parseArguments(options),\n      opts = args[0];\n\n  const discardOrDetachDescriptor = opts.discardDescriptor || opts.detachDescriptor;\n  const name = tmpNameSync(opts);\n  var fd = fs.openSync(name, CREATE_FLAGS, opts.mode || FILE_MODE);\n  /* istanbul ignore else */\n\n  if (opts.discardDescriptor) {\n    fs.closeSync(fd);\n    fd = undefined;\n  }\n\n  return {\n    name: name,\n    fd: fd,\n    removeCallback: _prepareTmpFileRemoveCallback(name, discardOrDetachDescriptor ? -1 : fd, opts)\n  };\n}\n/**\n * Creates a temporary directory.\n *\n * @param {(Options|dirCallback)} options the options or the callback function\n * @param {?dirCallback} callback\n */\n\n\nfunction dir(options, callback) {\n  var args = _parseArguments(options, callback),\n      opts = args[0],\n      cb = args[1]; // gets a temporary filename\n\n\n  tmpName(opts, function _tmpNameCreated(err, name) {\n    /* istanbul ignore else */\n    if (err) return cb(err); // create the directory\n\n    fs.mkdir(name, opts.mode || DIR_MODE, function _dirCreated(err) {\n      /* istanbul ignore else */\n      if (err) return cb(err);\n      cb(null, name, _prepareTmpDirRemoveCallback(name, opts));\n    });\n  });\n}\n/**\n * Synchronous version of dir.\n *\n * @param {Options} options\n * @returns {DirSyncObject} object consists of name and removeCallback\n * @throws {Error} if it cannot create a directory\n */\n\n\nfunction dirSync(options) {\n  var args = _parseArguments(options),\n      opts = args[0];\n\n  const name = tmpNameSync(opts);\n  fs.mkdirSync(name, opts.mode || DIR_MODE);\n  return {\n    name: name,\n    removeCallback: _prepareTmpDirRemoveCallback(name, opts)\n  };\n}\n/**\n * Removes files asynchronously.\n *\n * @param {Object} fdPath\n * @param {Function} next\n * @private\n */\n\n\nfunction _removeFileAsync(fdPath, next) {\n  const _handler = function (err) {\n    if (err && !isENOENT(err)) {\n      // reraise any unanticipated error\n      return next(err);\n    }\n\n    next();\n  };\n\n  if (0 <= fdPath[0]) fs.close(fdPath[0], function (err) {\n    fs.unlink(fdPath[1], _handler);\n  });else fs.unlink(fdPath[1], _handler);\n}\n/**\n * Removes files synchronously.\n *\n * @param {Object} fdPath\n * @private\n */\n\n\nfunction _removeFileSync(fdPath) {\n  try {\n    if (0 <= fdPath[0]) fs.closeSync(fdPath[0]);\n  } catch (e) {\n    // reraise any unanticipated error\n    if (!isEBADF(e) && !isENOENT(e)) throw e;\n  } finally {\n    try {\n      fs.unlinkSync(fdPath[1]);\n    } catch (e) {\n      // reraise any unanticipated error\n      if (!isENOENT(e)) throw e;\n    }\n  }\n}\n/**\n * Prepares the callback for removal of the temporary file.\n *\n * @param {string} name the path of the file\n * @param {number} fd file descriptor\n * @param {Object} opts\n * @returns {fileCallback}\n * @private\n */\n\n\nfunction _prepareTmpFileRemoveCallback(name, fd, opts) {\n  const removeCallbackSync = _prepareRemoveCallback(_removeFileSync, [fd, name]);\n\n  const removeCallback = _prepareRemoveCallback(_removeFileAsync, [fd, name], removeCallbackSync);\n\n  if (!opts.keep) _removeObjects.unshift(removeCallbackSync);\n  return removeCallback;\n}\n/**\n * Simple wrapper for rimraf.\n *\n * @param {string} dirPath\n * @param {Function} next\n * @private\n */\n\n\nfunction _rimrafRemoveDirWrapper(dirPath, next) {\n  rimraf(dirPath, next);\n}\n/**\n * Simple wrapper for rimraf.sync.\n *\n * @param {string} dirPath\n * @private\n */\n\n\nfunction _rimrafRemoveDirSyncWrapper(dirPath, next) {\n  try {\n    return next(null, rimraf.sync(dirPath));\n  } catch (err) {\n    return next(err);\n  }\n}\n/**\n * Prepares the callback for removal of the temporary directory.\n *\n * @param {string} name\n * @param {Object} opts\n * @returns {Function} the callback\n * @private\n */\n\n\nfunction _prepareTmpDirRemoveCallback(name, opts) {\n  const removeFunction = opts.unsafeCleanup ? _rimrafRemoveDirWrapper : fs.rmdir.bind(fs);\n  const removeFunctionSync = opts.unsafeCleanup ? _rimrafRemoveDirSyncWrapper : fs.rmdirSync.bind(fs);\n\n  const removeCallbackSync = _prepareRemoveCallback(removeFunctionSync, name);\n\n  const removeCallback = _prepareRemoveCallback(removeFunction, name, removeCallbackSync);\n\n  if (!opts.keep) _removeObjects.unshift(removeCallbackSync);\n  return removeCallback;\n}\n/**\n * Creates a guarded function wrapping the removeFunction call.\n *\n * @param {Function} removeFunction\n * @param {Object} arg\n * @returns {Function}\n * @private\n */\n\n\nfunction _prepareRemoveCallback(removeFunction, arg, cleanupCallbackSync) {\n  var called = false;\n  return function _cleanupCallback(next) {\n    next = next || function () {};\n\n    if (!called) {\n      const toRemove = cleanupCallbackSync || _cleanupCallback;\n\n      const index = _removeObjects.indexOf(toRemove);\n      /* istanbul ignore else */\n\n\n      if (index >= 0) _removeObjects.splice(index, 1);\n      called = true; // sync?\n\n      if (removeFunction.length === 1) {\n        try {\n          removeFunction(arg);\n          return next(null);\n        } catch (err) {\n          // if no next is provided and since we are\n          // in silent cleanup mode on process exit,\n          // we will ignore the error\n          return next(err);\n        }\n      } else return removeFunction(arg, next);\n    } else return next(new Error('cleanup callback has already been called'));\n  };\n}\n/**\n * The garbage collector.\n *\n * @private\n */\n\n\nfunction _garbageCollector() {\n  /* istanbul ignore else */\n  if (!_gracefulCleanup) return; // the function being called removes itself from _removeObjects,\n  // loop until _removeObjects is empty\n\n  while (_removeObjects.length) {\n    try {\n      _removeObjects[0]();\n    } catch (e) {// already removed?\n    }\n  }\n}\n/**\n * Helper for testing against EBADF to compensate changes made to Node 7.x under Windows.\n */\n\n\nfunction isEBADF(error) {\n  return isExpectedError(error, -EBADF, 'EBADF');\n}\n/**\n * Helper for testing against ENOENT to compensate changes made to Node 7.x under Windows.\n */\n\n\nfunction isENOENT(error) {\n  return isExpectedError(error, -ENOENT, 'ENOENT');\n}\n/**\n * Helper to determine whether the expected error code matches the actual code and errno,\n * which will differ between the supported node versions.\n *\n * - Node >= 7.0:\n *   error.code {string}\n *   error.errno {string|number} any numerical value will be negated\n *\n * - Node >= 6.0 < 7.0:\n *   error.code {string}\n *   error.errno {number} negated\n *\n * - Node >= 4.0 < 6.0: introduces SystemError\n *   error.code {string}\n *   error.errno {number} negated\n *\n * - Node >= 0.10 < 4.0:\n *   error.code {number} negated\n *   error.errno n/a\n */\n\n\nfunction isExpectedError(error, code, errno) {\n  return error.code === code || error.code === errno;\n}\n/**\n * Helper which determines whether a string s is blank, that is undefined, or empty or null.\n *\n * @private\n * @param {string} s\n * @returns {Boolean} true whether the string s is blank, false otherwise\n */\n\n\nfunction isBlank(s) {\n  return s === null || s === undefined || !s.trim();\n}\n/**\n * Sets the graceful cleanup.\n */\n\n\nfunction setGracefulCleanup() {\n  _gracefulCleanup = true;\n}\n/**\n * Returns the currently configured tmp dir from os.tmpdir().\n *\n * @private\n * @returns {string} the currently configured tmp dir\n */\n\n\nfunction _getTmpDir() {\n  return os.tmpdir();\n}\n/**\n * If there are multiple different versions of tmp in place, make sure that\n * we recognize the old listeners.\n *\n * @param {Function} listener\n * @private\n * @returns {Boolean} true whether listener is a legacy listener\n */\n\n\nfunction _is_legacy_listener(listener) {\n  return (listener.name === '_exit' || listener.name === '_uncaughtExceptionThrown') && listener.toString().indexOf('_garbageCollector();') > -1;\n}\n/**\n * Safely install SIGINT listener.\n *\n * NOTE: this will only work on OSX and Linux.\n *\n * @private\n */\n\n\nfunction _safely_install_sigint_listener() {\n  const listeners = process.listeners(SIGINT);\n  const existingListeners = [];\n\n  for (let i = 0, length = listeners.length; i < length; i++) {\n    const lstnr = listeners[i];\n    /* istanbul ignore else */\n\n    if (lstnr.name === '_tmp$sigint_listener') {\n      existingListeners.push(lstnr);\n      process.removeListener(SIGINT, lstnr);\n    }\n  }\n\n  process.on(SIGINT, function _tmp$sigint_listener(doExit) {\n    for (let i = 0, length = existingListeners.length; i < length; i++) {\n      // let the existing listener do the garbage collection (e.g. jest sandbox)\n      try {\n        existingListeners[i](false);\n      } catch (err) {// ignore\n      }\n    }\n\n    try {\n      // force the garbage collector even it is called again in the exit listener\n      _garbageCollector();\n    } finally {\n      if (!!doExit) {\n        process.exit(0);\n      }\n    }\n  });\n}\n/**\n * Safely install process exit listener.\n *\n * @private\n */\n\n\nfunction _safely_install_exit_listener() {\n  const listeners = process.listeners(EXIT); // collect any existing listeners\n\n  const existingListeners = [];\n\n  for (let i = 0, length = listeners.length; i < length; i++) {\n    const lstnr = listeners[i];\n    /* istanbul ignore else */\n    // TODO: remove support for legacy listeners once release 1.0.0 is out\n\n    if (lstnr.name === '_tmp$safe_listener' || _is_legacy_listener(lstnr)) {\n      // we must forget about the uncaughtException listener, hopefully it is ours\n      if (lstnr.name !== '_uncaughtExceptionThrown') {\n        existingListeners.push(lstnr);\n      }\n\n      process.removeListener(EXIT, lstnr);\n    }\n  } // TODO: what was the data parameter good for?\n\n\n  process.addListener(EXIT, function _tmp$safe_listener(data) {\n    for (let i = 0, length = existingListeners.length; i < length; i++) {\n      // let the existing listener do the garbage collection (e.g. jest sandbox)\n      try {\n        existingListeners[i](data);\n      } catch (err) {// ignore\n      }\n    }\n\n    _garbageCollector();\n  });\n}\n\n_safely_install_exit_listener();\n\n_safely_install_sigint_listener();\n/**\n * Configuration options.\n *\n * @typedef {Object} Options\n * @property {?number} tries the number of tries before give up the name generation\n * @property {?string} template the \"mkstemp\" like filename template\n * @property {?string} name fix name\n * @property {?string} dir the tmp directory to use\n * @property {?string} prefix prefix for the generated name\n * @property {?string} postfix postfix for the generated name\n * @property {?boolean} unsafeCleanup recursively removes the created temporary directory, even when it's not empty\n */\n\n/**\n * @typedef {Object} FileSyncObject\n * @property {string} name the name of the file\n * @property {string} fd the file descriptor\n * @property {fileCallback} removeCallback the callback function to remove the file\n */\n\n/**\n * @typedef {Object} DirSyncObject\n * @property {string} name the name of the directory\n * @property {fileCallback} removeCallback the callback function to remove the directory\n */\n\n/**\n * @callback tmpNameCallback\n * @param {?Error} err the error object if anything goes wrong\n * @param {string} name the temporary file name\n */\n\n/**\n * @callback fileCallback\n * @param {?Error} err the error object if anything goes wrong\n * @param {string} name the temporary file name\n * @param {number} fd the file descriptor\n * @param {cleanupCallback} fn the cleanup callback function\n */\n\n/**\n * @callback dirCallback\n * @param {?Error} err the error object if anything goes wrong\n * @param {string} name the temporary file name\n * @param {cleanupCallback} fn the cleanup callback function\n */\n\n/**\n * Removes the temporary created file or directory.\n *\n * @callback cleanupCallback\n * @param {simpleCallback} [next] function to call after entry was removed\n */\n\n/**\n * Callback function for function composition.\n * @see {@link https://github.com/raszi/node-tmp/issues/57|raszi/node-tmp#57}\n *\n * @callback simpleCallback\n */\n// exporting all the needed methods\n// evaluate os.tmpdir() lazily, mainly for simplifying testing but it also will\n// allow users to reconfigure the temporary directory\n\n\nObject.defineProperty(module.exports, 'tmpdir', {\n  enumerable: true,\n  configurable: false,\n  get: function () {\n    return _getTmpDir();\n  }\n});\nmodule.exports.dir = dir;\nmodule.exports.dirSync = dirSync;\nmodule.exports.file = file;\nmodule.exports.fileSync = fileSync;\nmodule.exports.tmpName = tmpName;\nmodule.exports.tmpNameSync = tmpNameSync;\nmodule.exports.setGracefulCleanup = setGracefulCleanup;","map":{"version":3,"sources":["/Users/yussefsoudan/Studies/Uni/year-4-cs/TTDS/CW3/ttds-14/website/book-search-client/node_modules/tmp/lib/tmp.js"],"names":["fs","require","os","path","crypto","_c","constants","process","binding","rimraf","RANDOM_CHARS","TEMPLATE_PATTERN","DEFAULT_TRIES","CREATE_FLAGS","O_CREAT","O_EXCL","O_RDWR","EBADF","errno","ENOENT","DIR_MODE","FILE_MODE","EXIT","SIGINT","_removeObjects","_gracefulCleanup","_randomChars","howMany","value","rnd","randomBytes","e","pseudoRandomBytes","i","push","length","join","_isUndefined","obj","_parseArguments","options","callback","_generateTmpName","opts","tmpDir","_getTmpDir","isBlank","dir","Error","name","template","basename","replace","prefix","pid","postfix","tmpName","args","cb","tries","isNaN","match","_getUniqueName","stat","err","tmpNameSync","statSync","file","_tmpNameCreated","open","mode","_fileCreated","fd","discardDescriptor","close","_discardCallback","unlinkSync","isENOENT","undefined","_prepareTmpFileRemoveCallback","detachDescriptor","fileSync","discardOrDetachDescriptor","openSync","closeSync","removeCallback","mkdir","_dirCreated","_prepareTmpDirRemoveCallback","dirSync","mkdirSync","_removeFileAsync","fdPath","next","_handler","unlink","_removeFileSync","isEBADF","removeCallbackSync","_prepareRemoveCallback","keep","unshift","_rimrafRemoveDirWrapper","dirPath","_rimrafRemoveDirSyncWrapper","sync","removeFunction","unsafeCleanup","rmdir","bind","removeFunctionSync","rmdirSync","arg","cleanupCallbackSync","called","_cleanupCallback","toRemove","index","indexOf","splice","_garbageCollector","error","isExpectedError","code","s","trim","setGracefulCleanup","tmpdir","_is_legacy_listener","listener","toString","_safely_install_sigint_listener","listeners","existingListeners","lstnr","removeListener","on","_tmp$sigint_listener","doExit","exit","_safely_install_exit_listener","addListener","_tmp$safe_listener","data","Object","defineProperty","module","exports","enumerable","configurable","get"],"mappings":"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","sourcesContent":["/*!\n * Tmp\n *\n * Copyright (c) 2011-2017 KARASZI Istvan <github@spam.raszi.hu>\n *\n * MIT Licensed\n */\n\n/*\n * Module dependencies.\n */\nconst fs = require('fs');\nconst os = require('os');\nconst path = require('path');\nconst crypto = require('crypto');\nconst _c = fs.constants && os.constants ?\n  { fs: fs.constants, os: os.constants } :\n  process.binding('constants');\nconst rimraf = require('rimraf');\n\n/*\n * The working inner variables.\n */\nconst\n  // the random characters to choose from\n  RANDOM_CHARS = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz',\n\n  TEMPLATE_PATTERN = /XXXXXX/,\n\n  DEFAULT_TRIES = 3,\n\n  CREATE_FLAGS = (_c.O_CREAT || _c.fs.O_CREAT) | (_c.O_EXCL || _c.fs.O_EXCL) | (_c.O_RDWR || _c.fs.O_RDWR),\n\n  EBADF = _c.EBADF || _c.os.errno.EBADF,\n  ENOENT = _c.ENOENT || _c.os.errno.ENOENT,\n\n  DIR_MODE = 448 /* 0o700 */,\n  FILE_MODE = 384 /* 0o600 */,\n\n  EXIT = 'exit',\n\n  SIGINT = 'SIGINT',\n\n  // this will hold the objects need to be removed on exit\n  _removeObjects = [];\n\nvar\n  _gracefulCleanup = false;\n\n/**\n * Random name generator based on crypto.\n * Adapted from http://blog.tompawlak.org/how-to-generate-random-values-nodejs-javascript\n *\n * @param {number} howMany\n * @returns {string} the generated random name\n * @private\n */\nfunction _randomChars(howMany) {\n  var\n    value = [],\n    rnd = null;\n\n  // make sure that we do not fail because we ran out of entropy\n  try {\n    rnd = crypto.randomBytes(howMany);\n  } catch (e) {\n    rnd = crypto.pseudoRandomBytes(howMany);\n  }\n\n  for (var i = 0; i < howMany; i++) {\n    value.push(RANDOM_CHARS[rnd[i] % RANDOM_CHARS.length]);\n  }\n\n  return value.join('');\n}\n\n/**\n * Checks whether the `obj` parameter is defined or not.\n *\n * @param {Object} obj\n * @returns {boolean} true if the object is undefined\n * @private\n */\nfunction _isUndefined(obj) {\n  return typeof obj === 'undefined';\n}\n\n/**\n * Parses the function arguments.\n *\n * This function helps to have optional arguments.\n *\n * @param {(Options|Function)} options\n * @param {Function} callback\n * @returns {Array} parsed arguments\n * @private\n */\nfunction _parseArguments(options, callback) {\n  /* istanbul ignore else */\n  if (typeof options === 'function') {\n    return [{}, options];\n  }\n\n  /* istanbul ignore else */\n  if (_isUndefined(options)) {\n    return [{}, callback];\n  }\n\n  return [options, callback];\n}\n\n/**\n * Generates a new temporary name.\n *\n * @param {Object} opts\n * @returns {string} the new random name according to opts\n * @private\n */\nfunction _generateTmpName(opts) {\n\n  const tmpDir = _getTmpDir();\n\n  // fail early on missing tmp dir\n  if (isBlank(opts.dir) && isBlank(tmpDir)) {\n    throw new Error('No tmp dir specified');\n  }\n\n  /* istanbul ignore else */\n  if (!isBlank(opts.name)) {\n    return path.join(opts.dir || tmpDir, opts.name);\n  }\n\n  // mkstemps like template\n  // opts.template has already been guarded in tmpName() below\n  /* istanbul ignore else */\n  if (opts.template) {\n    var template = opts.template;\n    // make sure that we prepend the tmp path if none was given\n    /* istanbul ignore else */\n    if (path.basename(template) === template)\n      template = path.join(opts.dir || tmpDir, template);\n    return template.replace(TEMPLATE_PATTERN, _randomChars(6));\n  }\n\n  // prefix and postfix\n  const name = [\n    (isBlank(opts.prefix) ? 'tmp-' : opts.prefix),\n    process.pid,\n    _randomChars(12),\n    (opts.postfix ? opts.postfix : '')\n  ].join('');\n\n  return path.join(opts.dir || tmpDir, name);\n}\n\n/**\n * Gets a temporary file name.\n *\n * @param {(Options|tmpNameCallback)} options options or callback\n * @param {?tmpNameCallback} callback the callback function\n */\nfunction tmpName(options, callback) {\n  var\n    args = _parseArguments(options, callback),\n    opts = args[0],\n    cb = args[1],\n    tries = !isBlank(opts.name) ? 1 : opts.tries || DEFAULT_TRIES;\n\n  /* istanbul ignore else */\n  if (isNaN(tries) || tries < 0)\n    return cb(new Error('Invalid tries'));\n\n  /* istanbul ignore else */\n  if (opts.template && !opts.template.match(TEMPLATE_PATTERN))\n    return cb(new Error('Invalid template provided'));\n\n  (function _getUniqueName() {\n    try {\n      const name = _generateTmpName(opts);\n\n      // check whether the path exists then retry if needed\n      fs.stat(name, function (err) {\n        /* istanbul ignore else */\n        if (!err) {\n          /* istanbul ignore else */\n          if (tries-- > 0) return _getUniqueName();\n\n          return cb(new Error('Could not get a unique tmp filename, max tries reached ' + name));\n        }\n\n        cb(null, name);\n      });\n    } catch (err) {\n      cb(err);\n    }\n  }());\n}\n\n/**\n * Synchronous version of tmpName.\n *\n * @param {Object} options\n * @returns {string} the generated random name\n * @throws {Error} if the options are invalid or could not generate a filename\n */\nfunction tmpNameSync(options) {\n  var\n    args = _parseArguments(options),\n    opts = args[0],\n    tries = !isBlank(opts.name) ? 1 : opts.tries || DEFAULT_TRIES;\n\n  /* istanbul ignore else */\n  if (isNaN(tries) || tries < 0)\n    throw new Error('Invalid tries');\n\n  /* istanbul ignore else */\n  if (opts.template && !opts.template.match(TEMPLATE_PATTERN))\n    throw new Error('Invalid template provided');\n\n  do {\n    const name = _generateTmpName(opts);\n    try {\n      fs.statSync(name);\n    } catch (e) {\n      return name;\n    }\n  } while (tries-- > 0);\n\n  throw new Error('Could not get a unique tmp filename, max tries reached');\n}\n\n/**\n * Creates and opens a temporary file.\n *\n * @param {(Options|fileCallback)} options the config options or the callback function\n * @param {?fileCallback} callback\n */\nfunction file(options, callback) {\n  var\n    args = _parseArguments(options, callback),\n    opts = args[0],\n    cb = args[1];\n\n  // gets a temporary filename\n  tmpName(opts, function _tmpNameCreated(err, name) {\n    /* istanbul ignore else */\n    if (err) return cb(err);\n\n    // create and open the file\n    fs.open(name, CREATE_FLAGS, opts.mode || FILE_MODE, function _fileCreated(err, fd) {\n      /* istanbul ignore else */\n      if (err) return cb(err);\n\n      if (opts.discardDescriptor) {\n        return fs.close(fd, function _discardCallback(err) {\n          /* istanbul ignore else */\n          if (err) {\n            // Low probability, and the file exists, so this could be\n            // ignored.  If it isn't we certainly need to unlink the\n            // file, and if that fails too its error is more\n            // important.\n            try {\n              fs.unlinkSync(name);\n            } catch (e) {\n              if (!isENOENT(e)) {\n                err = e;\n              }\n            }\n            return cb(err);\n          }\n          cb(null, name, undefined, _prepareTmpFileRemoveCallback(name, -1, opts));\n        });\n      }\n      /* istanbul ignore else */\n      if (opts.detachDescriptor) {\n        return cb(null, name, fd, _prepareTmpFileRemoveCallback(name, -1, opts));\n      }\n      cb(null, name, fd, _prepareTmpFileRemoveCallback(name, fd, opts));\n    });\n  });\n}\n\n/**\n * Synchronous version of file.\n *\n * @param {Options} options\n * @returns {FileSyncObject} object consists of name, fd and removeCallback\n * @throws {Error} if cannot create a file\n */\nfunction fileSync(options) {\n  var\n    args = _parseArguments(options),\n    opts = args[0];\n\n  const discardOrDetachDescriptor = opts.discardDescriptor || opts.detachDescriptor;\n  const name = tmpNameSync(opts);\n  var fd = fs.openSync(name, CREATE_FLAGS, opts.mode || FILE_MODE);\n  /* istanbul ignore else */\n  if (opts.discardDescriptor) {\n    fs.closeSync(fd);\n    fd = undefined;\n  }\n\n  return {\n    name: name,\n    fd: fd,\n    removeCallback: _prepareTmpFileRemoveCallback(name, discardOrDetachDescriptor ? -1 : fd, opts)\n  };\n}\n\n/**\n * Creates a temporary directory.\n *\n * @param {(Options|dirCallback)} options the options or the callback function\n * @param {?dirCallback} callback\n */\nfunction dir(options, callback) {\n  var\n    args = _parseArguments(options, callback),\n    opts = args[0],\n    cb = args[1];\n\n  // gets a temporary filename\n  tmpName(opts, function _tmpNameCreated(err, name) {\n    /* istanbul ignore else */\n    if (err) return cb(err);\n\n    // create the directory\n    fs.mkdir(name, opts.mode || DIR_MODE, function _dirCreated(err) {\n      /* istanbul ignore else */\n      if (err) return cb(err);\n\n      cb(null, name, _prepareTmpDirRemoveCallback(name, opts));\n    });\n  });\n}\n\n/**\n * Synchronous version of dir.\n *\n * @param {Options} options\n * @returns {DirSyncObject} object consists of name and removeCallback\n * @throws {Error} if it cannot create a directory\n */\nfunction dirSync(options) {\n  var\n    args = _parseArguments(options),\n    opts = args[0];\n\n  const name = tmpNameSync(opts);\n  fs.mkdirSync(name, opts.mode || DIR_MODE);\n\n  return {\n    name: name,\n    removeCallback: _prepareTmpDirRemoveCallback(name, opts)\n  };\n}\n\n/**\n * Removes files asynchronously.\n *\n * @param {Object} fdPath\n * @param {Function} next\n * @private\n */\nfunction _removeFileAsync(fdPath, next) {\n  const _handler = function (err) {\n    if (err && !isENOENT(err)) {\n      // reraise any unanticipated error\n      return next(err);\n    }\n    next();\n  }\n\n  if (0 <= fdPath[0])\n    fs.close(fdPath[0], function (err) {\n      fs.unlink(fdPath[1], _handler);\n    });\n  else fs.unlink(fdPath[1], _handler);\n}\n\n/**\n * Removes files synchronously.\n *\n * @param {Object} fdPath\n * @private\n */\nfunction _removeFileSync(fdPath) {\n  try {\n    if (0 <= fdPath[0]) fs.closeSync(fdPath[0]);\n  } catch (e) {\n    // reraise any unanticipated error\n    if (!isEBADF(e) && !isENOENT(e)) throw e;\n  } finally {\n    try {\n      fs.unlinkSync(fdPath[1]);\n    }\n    catch (e) {\n      // reraise any unanticipated error\n      if (!isENOENT(e)) throw e;\n    }\n  }\n}\n\n/**\n * Prepares the callback for removal of the temporary file.\n *\n * @param {string} name the path of the file\n * @param {number} fd file descriptor\n * @param {Object} opts\n * @returns {fileCallback}\n * @private\n */\nfunction _prepareTmpFileRemoveCallback(name, fd, opts) {\n  const removeCallbackSync = _prepareRemoveCallback(_removeFileSync, [fd, name]);\n  const removeCallback = _prepareRemoveCallback(_removeFileAsync, [fd, name], removeCallbackSync);\n\n  if (!opts.keep) _removeObjects.unshift(removeCallbackSync);\n\n  return removeCallback;\n}\n\n/**\n * Simple wrapper for rimraf.\n *\n * @param {string} dirPath\n * @param {Function} next\n * @private\n */\nfunction _rimrafRemoveDirWrapper(dirPath, next) {\n  rimraf(dirPath, next);\n}\n\n/**\n * Simple wrapper for rimraf.sync.\n *\n * @param {string} dirPath\n * @private\n */\nfunction _rimrafRemoveDirSyncWrapper(dirPath, next) {\n  try {\n    return next(null, rimraf.sync(dirPath));\n  } catch (err) {\n    return next(err);\n  }\n}\n\n/**\n * Prepares the callback for removal of the temporary directory.\n *\n * @param {string} name\n * @param {Object} opts\n * @returns {Function} the callback\n * @private\n */\nfunction _prepareTmpDirRemoveCallback(name, opts) {\n  const removeFunction = opts.unsafeCleanup ? _rimrafRemoveDirWrapper : fs.rmdir.bind(fs);\n  const removeFunctionSync = opts.unsafeCleanup ? _rimrafRemoveDirSyncWrapper : fs.rmdirSync.bind(fs);\n  const removeCallbackSync = _prepareRemoveCallback(removeFunctionSync, name);\n  const removeCallback = _prepareRemoveCallback(removeFunction, name, removeCallbackSync);\n  if (!opts.keep) _removeObjects.unshift(removeCallbackSync);\n\n  return removeCallback;\n}\n\n/**\n * Creates a guarded function wrapping the removeFunction call.\n *\n * @param {Function} removeFunction\n * @param {Object} arg\n * @returns {Function}\n * @private\n */\nfunction _prepareRemoveCallback(removeFunction, arg, cleanupCallbackSync) {\n  var called = false;\n\n  return function _cleanupCallback(next) {\n    next = next || function () {};\n    if (!called) {\n      const toRemove = cleanupCallbackSync || _cleanupCallback;\n      const index = _removeObjects.indexOf(toRemove);\n      /* istanbul ignore else */\n      if (index >= 0) _removeObjects.splice(index, 1);\n\n      called = true;\n      // sync?\n      if (removeFunction.length === 1) {\n        try {\n          removeFunction(arg);\n          return next(null);\n        }\n        catch (err) {\n          // if no next is provided and since we are\n          // in silent cleanup mode on process exit,\n          // we will ignore the error\n          return next(err);\n        }\n      } else return removeFunction(arg, next);\n    } else return next(new Error('cleanup callback has already been called'));\n  };\n}\n\n/**\n * The garbage collector.\n *\n * @private\n */\nfunction _garbageCollector() {\n  /* istanbul ignore else */\n  if (!_gracefulCleanup) return;\n\n  // the function being called removes itself from _removeObjects,\n  // loop until _removeObjects is empty\n  while (_removeObjects.length) {\n    try {\n      _removeObjects[0]();\n    } catch (e) {\n      // already removed?\n    }\n  }\n}\n\n/**\n * Helper for testing against EBADF to compensate changes made to Node 7.x under Windows.\n */\nfunction isEBADF(error) {\n  return isExpectedError(error, -EBADF, 'EBADF');\n}\n\n/**\n * Helper for testing against ENOENT to compensate changes made to Node 7.x under Windows.\n */\nfunction isENOENT(error) {\n  return isExpectedError(error, -ENOENT, 'ENOENT');\n}\n\n/**\n * Helper to determine whether the expected error code matches the actual code and errno,\n * which will differ between the supported node versions.\n *\n * - Node >= 7.0:\n *   error.code {string}\n *   error.errno {string|number} any numerical value will be negated\n *\n * - Node >= 6.0 < 7.0:\n *   error.code {string}\n *   error.errno {number} negated\n *\n * - Node >= 4.0 < 6.0: introduces SystemError\n *   error.code {string}\n *   error.errno {number} negated\n *\n * - Node >= 0.10 < 4.0:\n *   error.code {number} negated\n *   error.errno n/a\n */\nfunction isExpectedError(error, code, errno) {\n  return error.code === code || error.code === errno;\n}\n\n/**\n * Helper which determines whether a string s is blank, that is undefined, or empty or null.\n *\n * @private\n * @param {string} s\n * @returns {Boolean} true whether the string s is blank, false otherwise\n */\nfunction isBlank(s) {\n  return s === null || s === undefined || !s.trim();\n}\n\n/**\n * Sets the graceful cleanup.\n */\nfunction setGracefulCleanup() {\n  _gracefulCleanup = true;\n}\n\n/**\n * Returns the currently configured tmp dir from os.tmpdir().\n *\n * @private\n * @returns {string} the currently configured tmp dir\n */\nfunction _getTmpDir() {\n  return os.tmpdir();\n}\n\n/**\n * If there are multiple different versions of tmp in place, make sure that\n * we recognize the old listeners.\n *\n * @param {Function} listener\n * @private\n * @returns {Boolean} true whether listener is a legacy listener\n */\nfunction _is_legacy_listener(listener) {\n  return (listener.name === '_exit' || listener.name === '_uncaughtExceptionThrown')\n    && listener.toString().indexOf('_garbageCollector();') > -1;\n}\n\n/**\n * Safely install SIGINT listener.\n *\n * NOTE: this will only work on OSX and Linux.\n *\n * @private\n */\nfunction _safely_install_sigint_listener() {\n\n  const listeners = process.listeners(SIGINT);\n  const existingListeners = [];\n  for (let i = 0, length = listeners.length; i < length; i++) {\n    const lstnr = listeners[i];\n    /* istanbul ignore else */\n    if (lstnr.name === '_tmp$sigint_listener') {\n      existingListeners.push(lstnr);\n      process.removeListener(SIGINT, lstnr);\n    }\n  }\n  process.on(SIGINT, function _tmp$sigint_listener(doExit) {\n    for (let i = 0, length = existingListeners.length; i < length; i++) {\n      // let the existing listener do the garbage collection (e.g. jest sandbox)\n      try {\n        existingListeners[i](false);\n      } catch (err) {\n        // ignore\n      }\n    }\n    try {\n      // force the garbage collector even it is called again in the exit listener\n      _garbageCollector();\n    } finally {\n      if (!!doExit) {\n        process.exit(0);\n      }\n    }\n  });\n}\n\n/**\n * Safely install process exit listener.\n *\n * @private\n */\nfunction _safely_install_exit_listener() {\n  const listeners = process.listeners(EXIT);\n\n  // collect any existing listeners\n  const existingListeners = [];\n  for (let i = 0, length = listeners.length; i < length; i++) {\n    const lstnr = listeners[i];\n    /* istanbul ignore else */\n    // TODO: remove support for legacy listeners once release 1.0.0 is out\n    if (lstnr.name === '_tmp$safe_listener' || _is_legacy_listener(lstnr)) {\n      // we must forget about the uncaughtException listener, hopefully it is ours\n      if (lstnr.name !== '_uncaughtExceptionThrown') {\n        existingListeners.push(lstnr);\n      }\n      process.removeListener(EXIT, lstnr);\n    }\n  }\n  // TODO: what was the data parameter good for?\n  process.addListener(EXIT, function _tmp$safe_listener(data) {\n    for (let i = 0, length = existingListeners.length; i < length; i++) {\n      // let the existing listener do the garbage collection (e.g. jest sandbox)\n      try {\n        existingListeners[i](data);\n      } catch (err) {\n        // ignore\n      }\n    }\n    _garbageCollector();\n  });\n}\n\n_safely_install_exit_listener();\n_safely_install_sigint_listener();\n\n/**\n * Configuration options.\n *\n * @typedef {Object} Options\n * @property {?number} tries the number of tries before give up the name generation\n * @property {?string} template the \"mkstemp\" like filename template\n * @property {?string} name fix name\n * @property {?string} dir the tmp directory to use\n * @property {?string} prefix prefix for the generated name\n * @property {?string} postfix postfix for the generated name\n * @property {?boolean} unsafeCleanup recursively removes the created temporary directory, even when it's not empty\n */\n\n/**\n * @typedef {Object} FileSyncObject\n * @property {string} name the name of the file\n * @property {string} fd the file descriptor\n * @property {fileCallback} removeCallback the callback function to remove the file\n */\n\n/**\n * @typedef {Object} DirSyncObject\n * @property {string} name the name of the directory\n * @property {fileCallback} removeCallback the callback function to remove the directory\n */\n\n/**\n * @callback tmpNameCallback\n * @param {?Error} err the error object if anything goes wrong\n * @param {string} name the temporary file name\n */\n\n/**\n * @callback fileCallback\n * @param {?Error} err the error object if anything goes wrong\n * @param {string} name the temporary file name\n * @param {number} fd the file descriptor\n * @param {cleanupCallback} fn the cleanup callback function\n */\n\n/**\n * @callback dirCallback\n * @param {?Error} err the error object if anything goes wrong\n * @param {string} name the temporary file name\n * @param {cleanupCallback} fn the cleanup callback function\n */\n\n/**\n * Removes the temporary created file or directory.\n *\n * @callback cleanupCallback\n * @param {simpleCallback} [next] function to call after entry was removed\n */\n\n/**\n * Callback function for function composition.\n * @see {@link https://github.com/raszi/node-tmp/issues/57|raszi/node-tmp#57}\n *\n * @callback simpleCallback\n */\n\n// exporting all the needed methods\n\n// evaluate os.tmpdir() lazily, mainly for simplifying testing but it also will\n// allow users to reconfigure the temporary directory\nObject.defineProperty(module.exports, 'tmpdir', {\n  enumerable: true,\n  configurable: false,\n  get: function () {\n    return _getTmpDir();\n  }\n});\n\nmodule.exports.dir = dir;\nmodule.exports.dirSync = dirSync;\n\nmodule.exports.file = file;\nmodule.exports.fileSync = fileSync;\n\nmodule.exports.tmpName = tmpName;\nmodule.exports.tmpNameSync = tmpNameSync;\n\nmodule.exports.setGracefulCleanup = setGracefulCleanup;\n"]},"metadata":{},"sourceType":"script"}